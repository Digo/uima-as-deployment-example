<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UIMA Asynchronous Scaleout</title><link rel="stylesheet" type="text/css" href="css/stylesheet-html.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="UIMA Asynchronous Scaleout" id="d5e1"><div xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div><h1 class="title">UIMA Asynchronous Scaleout</h1></div><div><div class="authorgroup">
      <h3 class="corpauthor">Written and maintained by the Apache UIMA&#8482; Development Community</h3>
    </div></div><div><p class="releaseinfo">Version 2.4.0</p></div><div><p class="copyright">Copyright &copy; 2006, 2012 The Apache Software Foundation</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d5e8"></a>
      <p> </p>
      <p title="License and Disclaimer">
        <b>License and Disclaimer.&nbsp;</b>

        The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote">
           <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
         </blockquote></div><p title="License and Disclaimer">
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         
      </p>
      <p> </p>
      <p> </p>
      <p title="Trademarks">
        <b>Trademarks.&nbsp;</b>
        All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        
      </p>
    </div></div><div><p class="pubdate">November, 2012</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#ugr.async.ov">1. Overview - Asynchronous Scaleout</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.ov.terminology">1.1. Terminology</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.as_vs_cpm">1.2. AS versus CPM</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.design_goals">1.3. Design goals for Asynchronous Scaleout</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts">1.4. AS Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.ov.concepts.threading">1.4.1. Threading</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.wrapping">1.4.2. AS Component wrapping</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.parallelFlows">1.4.3. Parallel Flows</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.deploying">1.4.4. Deployment alternatives</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.first_limits">1.4.5. Limits</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.first_limits.compatibility">1.4.6. Compatibility</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.ov.concepts.application">1.5. Application Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.ov.concepts.application.api">1.5.1. Application API</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.collection_process_complete">1.5.2. Collection Process Complete</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.ov.concepts.mc">1.6. Monitoring &amp; Controlling</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.jms_descriptor">1.7. JMS Service Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.async.ov.concepts.lifecycle">1.8. Life cycle</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.async.eh">2. Error Handling for Asynchronous Scaleout</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.eh.basic">2.1. Basic concepts</a></span></dt><dt><span class="section"><a href="#ugr.async.eh.incoming_commands">2.2. Associating Errors with incoming commands</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.asynch.eh.cas_multipliers">2.2.1. Error handling - CAS Multipliers</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.eh.error_handling_overview">2.3. Error handling overview</a></span></dt><dt><span class="section"><a href="#ugr.async.eh.error_results">2.4. Error results</a></span></dt><dt><span class="section"><a href="#ugr.async.eh.aggregate_managed">2.5. Error Recovery actions</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.eh.aggregate_managed.actions">2.5.1. Aggregate Error Actions</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.eh.errors_passed_up.thresholds">2.6. Thresholds for Terminate and Disable</a></span></dt><dt><span class="section"><a href="#ugr.async.eh.terminate">2.7. Terminate Action</a></span></dt><dt><span class="section"><a href="#ugr.async.eh.commands_allowed_actions">2.8. Commands and allowed actions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.ref.async.deploy">3. Asynchronous Scaleout Deployment Descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor_organization">3.1. Descriptor Organization</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor">3.2. Deployment Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.caspool">3.3. CAS Pool</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.service">3.4. Service</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.custom">3.5. Customizing the deployment</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.input_queue">3.6. Input Queue</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.top_descriptor">3.7. Top Level AE Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.environment_variables">3.8. Setting Environment Variables</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.ae">3.9. Analysis Engine</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.errorconfig">3.10. Error Configuration descriptors</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.deploy.descriptor.errorconfig.defaults">3.11. Error Configuration defaults</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.ref.async.api">4. Asynchronous Scaleout Application Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.ref.async.api.organization">4.1. Async Client API</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.descriptor">4.2. The UimaAsynchronousEngine Interface</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.context.map">4.3. Application Context Map</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.callback.listener">4.4. Status Callback Listener</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.error.status">4.5. Error Results</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.usage">4.6. Asynchronous Client API Usage Scenarios</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.ref.async.api.usage_initialize">4.6.1. Instantiating a Client API Object</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.usage_callservice">4.6.2. Calling an Existing Service</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.usage_getresults">4.6.3. Retrieving Asynchronous Results</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.usage_deployservice">4.6.4. Deploying a Service with the Client API</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.ref.async.api.usage_undeployservice">4.7. Undeploying a Service with the Client API</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.recovery">4.8. Recovering from broker failure</a></span></dt><dt><span class="section"><a href="#ref.async.api.descriptor.generation">4.9. Generating Deployment Descriptor Programmatically</a></span></dt><dt><span class="section"><a href="#ugr.ref.async.api.sample.code">4.10. Sample Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.async.mt">5. Monitoring, Tuning and Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.mt.monitoring">5.1. Monitoring</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.mt.jmx">5.1.1. JMX</a></span></dt><dt><span class="section"><a href="#ugr.async.mt.jmx_monitoring">5.1.2. JMX Information from UIMA AS</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.mt.jmx_sampling">5.2. Logging Sampled JMX information at intervals</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.mt.jmx_sampling.configuring">5.2.1. Configuring JVM to run the monitor</a></span></dt><dt><span class="section"><a href="#ugr.async.mt.jmx_sampling.standalone">5.2.2. Running the Monitor program standalone</a></span></dt><dt><span class="section"><a href="#ugr.async.mt.jmx_sampling.output">5.2.3. Monitoring output</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.mt.tuning">5.3. Tuning</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.mt.tuning.approach">5.3.1. Tuning procedure</a></span></dt><dt><span class="section"><a href="#ugr.async.mt.tuning.settings">5.3.2. Tuning Settings</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.async.mt.debugging">5.4. Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.mt.debugging.tracing">5.4.1. Error Reporting and Tracing</a></span></dt><dt><span class="section"><a href="#ugr.async.mt.debugging.caslogging">5.4.2. CAS Logging</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ugr.async.camel.driver">6. Asynchronous Scaleout Camel Driver</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.camel.driver.component.overview">6.1. Overview</a></span></dt><dt><span class="section"><a href="#ugr.async.camel.driver.component">6.2. How does it work?</a></span></dt><dt><span class="section"><a href="#ugr.async.camel.driver.uri.format">6.3. URI Format</a></span></dt><dt><span class="section"><a href="#ugr.async.camel.driver.sample">6.4. Sample</a></span></dt><dt><span class="section"><a href="#ugr.async.camel.driver.implementation">6.5. Implementation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.async.tools">7. Asynchronous Scaleout Tools</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.async.tools.overview">7.1. Overview</a></span></dt><dt><span class="section"><a href="#ugr.async.tools.startBroker">7.2. Starting a broker</a></span></dt><dt><span class="section"><a href="#ugr.async.tools.deploying">7.3. Deploying a UIMA-AS Service</a></span></dt><dt><span class="section"><a href="#ugr.async.tools.client">7.4. Running a UIMA-AS Client</a></span></dt><dt><span class="section"><a href="#ugr.async.tools.getMeta">7.5. Querying for a service's metadata</a></span></dt></dl></dd></dl></div>
  
  
  

  

  <div class="chapter" title="Chapter&nbsp;1.&nbsp;Overview - Asynchronous Scaleout" id="ugr.async.ov"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Overview - Asynchronous Scaleout</h2></div></div></div>
  
  <p>UIMA Asynchronous Scaleout (AS) is a set of capabilities supported in the UIMA Framework for achieving
    scaleout that is more general than the approaches provided for in the Collection Processing Manager (CPM). AS is a
    second generation design, replacing the CPM and Vinci Services. The CPM and Vinci are still available and are not
    being deprecated, but new designs are encouraged to use AS for scalability, and current designs reaching
    limitations may want to move to AS.</p>
  <p>AS is integrated with the flow controller architecture, and can be applied to both primitive and aggregate
    analysis engines. </p>
  
  <div class="section" title="1.1.&nbsp;Terminology"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.terminology">1.1.&nbsp;Terminology</h2></div></div></div>
    
    <p>Terms used in describing AS capabilities include: </p>
    <div class="variablelist"><dl><dt><span class="term"> <span class="bold"><strong>AS</strong></span></span></dt><dd>
          <p>Asynchronous Scaleout - a name given to the capability described here</p></dd><dt><span class="term"> <span class="bold"><strong>AS-JMS/AMQ/Spring</strong></span></span></dt><dd>
          <p>A variety of AS, based on JMS (Java Messaging Services), Active MQ, an Apache Open Source
            implementation of JMS, and the Spring framework. This variety is the one described in detail in this
            document. </p></dd><dt><span class="term"> <span class="bold"><strong>Queue</strong></span></span></dt><dd>
          <p>Queues are the basic mechanism of asynchronous communication. One or more "producers"
            send messages to a queue, and a queue can have one or more "consumers" that receive messages.
            Messages in UIMA AS are usually CASes, or references to CASes. 
            Some queues are simple internal structures; others are JMS queues which are identified by a 2 part name: the
            first part is the Queue Broker; the second part is a Queue Name.</p></dd><dt><span class="term"> <span class="bold"><strong>AS Component</strong></span></span></dt><dd>
          <p>An AS client or service. AS clients send requests to AS service queues and receive back responses on
            reply queues. AS services can be AS Primitives or AS aggregates (see following).</p>
          </dd><dt><span class="term"> <span class="bold"><strong>AS Primitive</strong></span></span></dt><dd>
          <p>An AS service that is either a Primitive Analysis Engine
             or an Aggregate AE whose Delegates are <span class="bold"><strong>
            not</strong></span> AS-enabled</p></dd><dt><span class="term"> <span class="bold"><strong>AS Aggregate</strong></span></span></dt><dd>
          <p>An AS service that is an Aggregate Analysis Engine where the Delegates are also AS
            components.</p></dd><dt><span class="term"> <span class="bold"><strong>AS Client</strong></span></span></dt><dd>
          <p>A component sending requests to AS services. An AS client is typically an application using the UIMA
            AS client API, a JMS Service Client Proxy, or an AS Aggregate.</p></dd><dt><span class="term"> <span class="bold"><strong>co-located</strong></span></span></dt><dd>
          <p>two running pieces of code are co-located if they run in the same JVM and share the same UIMA framework
            implementation and components.</p></dd><dt><span class="term"> <span class="bold"><strong>Queue Broker</strong></span></span></dt><dd>
          <p>Queue brokers manage one or more named queues. The brokers are identified using a URL, representing
            where they are on the network. When the queue broker is co-located with the AS client and service, CASes
            are passed by reference, avoiding serialization / deserialization. </p></dd><dt><span class="term"> <span class="bold"><strong>Transport Connector</strong></span></span></dt><dd>
          <p>AS components connect to queue brokers via transport connectors. UIMA AS will typically use
            "tcp" connectors. "http" connectors are also available, and are useful for
            tunneling through firewalls via an existing public web server.</p></dd></dl></div></div>
  <div class="section" title="1.2.&nbsp;AS versus CPM"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.as_vs_cpm">1.2.&nbsp;AS versus CPM</h2></div></div></div>
    
    <p>It is useful to compare and contrast the approaches and capabilities of AS and CPM.</p>
    <div class="informaltable">
      <table width="100%" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">&nbsp;</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">AS</th><th style="border-bottom: 0.5pt solid black; " align="center">CPM</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Putting components together</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">
              <p>Provides a consistent, single, unified way to put components together, using
                the base UIMA "aggregate" capability.</p>
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">
              <p> <span class="bold"><strong>Two methods of putting components together</strong></span>
                </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
                    <p>CPE (Collection Processing Engine) descriptor, which has sections specifying a
                      Collection Reader, and a set of CAS Processors</p></li><li class="listitem">
                    <p>Each CAS Processor can, as well, be an aggregate</p></li></ol></div><p>
                </p>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Kinds of Aggregates</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">
              <p>An aggregate can be run <span class="bold"><strong>asynchronously</strong></span> using the AS
                mechanism, with a queue in front of each delegate, or it can by run <span class="bold"><strong>
                synchronously</strong></span>.
              </p>
              <p>
                When run asynchronously, <span class="emphasis"><em>all</em></span> of the
                delegates will have queues in front of them, and delegates which are AS Primitives can be individually scaled
                out (replicated) as needed.
                Also, multiple CASes can be in-process, at different steps in the pipeline, even without 
                replicating any components.</p>
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">All aggregates are run synchronously. In an aggregate, only one component is running at a
              time; there is only one CAS at a time being processed within the aggregate.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">CAS flow</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Any, including custom user-defined sequence using user-provided flow controller.  
              Parallel flows are supported.
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">Fixed linear flow between CAS processors. A single CAS processor can be an aggregate, and within
              the aggregate, can have any flow including custom user-defined sequence using user-provided flow
              controller.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Threading</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Each instance of a component runs in its own thread; the same thread used to call 
              <code class="code">initialize()</code> for a particular instance of a component
              is used when calling <code class="code">process()</code>.</td><td style="border-bottom: 0.5pt solid black; " valign="middle">One thread for the collection reader, one for the CAS Consumers, "n" threads for the
              main pipeline, with no guarantees that the same thread for the <code class="code">initialize()</code> call
              is used for the <code class="code">process()</code> call.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Delegate deployment</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Co-located or remote.</td><td style="border-bottom: 0.5pt solid black; " valign="middle">Co-located or remote.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Life cycle management</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">
              <p>Scripts to launch services, launch Queue Brokers.</p>
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">
              <p>Scripts to launch services, start Vinci Name Service.</p>
              <p>In addition, CPE "managed" configuration provides for automatic launching of
                UIMA Vinci services in same machine, in different processes. </p>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Error recovery</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">
              <p>Similar capabilities as the CPM provides for CAS Processors, but at the finer granularity of
                each AS component. The support includes customizable behavior overrides and extensions via user
                code. </p>
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">
              <p>Error detection, thresholding, and recovery options at the granularity of CAS Processors
                (which are CPM components, not delegates of aggregates), with some customizable callback
                notifications</p>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Firewall interactions</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Enables deployment of AS services behind a firewall using a public broker. Enables deployment
              of a public broker through single port, or using HTTP "tunneling".</td><td style="border-bottom: 0.5pt solid black; " valign="middle">When using Vinci protocol, requires opening a large number of ports for each deployed service.
              SOAP connected services require one open port.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">Monitoring and Tuning</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " valign="middle">
              <p>JMX (Java Management Extensions) are enabled for recording many kinds of statistical
                information, and can be used to monitor (and control) the operations of AS
                configured systems.  Statistics are provided and summarized from remote delegates, to aid in tuning
                scaled-out deployments.</p>
            </td><td style="border-bottom: 0.5pt solid black; " valign="middle">
              <p>Some JMX information</p>
            </td></tr><tr><td style="border-right: 0.5pt solid black; " valign="middle">Collection Reader</td><td style="border-right: 0.5pt solid black; " valign="middle">Supported for backwards compatibility. New programs should use the CAS Multiplier instead,
              which is more general, or have the application pass in CASes to be processed. The compatibility
              support wraps Collection Readers as Cas Multipliers.  Note: this is supported and implemented in base UIMA.</td><td style="" valign="middle">Is always first element in linear CPE sequence chain</td></tr></tbody></table>
    </div>
    </div>
  
  
  
  <div class="section" title="1.3.&nbsp;Design goals for Asynchronous Scaleout"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.design_goals">1.3.&nbsp;Design goals for Asynchronous Scaleout</h2></div></div></div>
    
    <p>The design goals for AS are:
      </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
          <p>Increased flexibility and options for scaleout (versus CPM)</p>
          <div class="orderedlist"><ol class="orderedlist" type="a" compact><li class="listitem">
              <p>scale out parts independently of other parts, to appropriate degree</p></li><li class="listitem">
              <p>more options for protocols for remote connections, including some that don't require many
                ports through firewalls</p></li><li class="listitem">
              <p>
                support multiple CASes in process simultaneously within an aggregate pipeline</p></li></ol></div></li><li class="listitem">
          <p>Build upon widely accepted Apache-licensed open source middleware</p></li><li class="listitem">
          <p>Simplification:
            </p><div class="orderedlist"><ol class="orderedlist" type="a" compact><li class="listitem">
                <p>Standardize on single approach to aggregate components</p></li><li class="listitem">
                <p>More uniform Error handling / recovery / monitoring for all AS managed components. </p>
              </li><li class="listitem"><p>No changes to existing annotator code or descriptors. An additional deployment
                descriptor is used to augment the conventional descriptors.</p></li></ol></div><p> </p></li></ol></div><p> </p></div>
  
  
  
  <div class="section" title="1.4.&nbsp;AS Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.concepts">1.4.&nbsp;AS Concepts</h2></div></div></div>
    
    <div class="section" title="1.4.1.&nbsp;User written components and multi-threading"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.threading">1.4.1.&nbsp;User written components and multi-threading</h3></div></div></div>
      
      
      <p>AS provides for scaling out of annotators - both aggregates and primitives. Each of these can specify a
        user-written implementation class. For primitives, this is the annotator class with the process() method
        that does the work. For aggregates, this can be an (optional) custom flow controller class that computes the
        flow. </p>
      <p>The classes for annotators and flow controllers do not need to be "thread-safe" with respect
        to their instance data - meaning, they do not need to be implemented with synchronization locks for access to
        their instance data, because each instance will only be called using one thread at a time. Scale out for these
        classes is done using multiple instances of the class.</p>
      <p>However, if you have class "static" fields shared by all instances, or other kinds of
        external data shared by all instances (such as a writable file), you must be aware of the possibility of
        multiple threads accessing these fields or external resources, running on separate instances of the class,
        and do any required synchronization for these. </p></div>
    
    
    
    <div class="section" title="1.4.2.&nbsp;AS Component wrapping"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.wrapping">1.4.2.&nbsp;AS Component wrapping</h3></div></div></div>
      
      <p>Components managed by AS
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            <p>have an associated input queue (this may be internal, or explicit and externalized).</p>
            <p>They receive work units (CASes) from this queue, and return the updated CASes to an output queue
              which is specified as part of the message delivering the input work unit (CAS).</p></li><li class="listitem">
            <p>have a container which wraps the component and provides the following services (see <a class="xref" href="#ugr.async.ov.fig.wrapAE" title="Figure&nbsp;1.1.&nbsp;AS Primitive Wrapper">Figure&nbsp;1.1, &#8220;AS Primitive Wrapper&#8221;</a>):
              </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
                  <p>A connection to an input queue of CASes to be processed</p></li><li class="listitem">
                  <p>Scale-out within the JVM for components at the bottom level - the AS Primitives. Scaleout
                    creates multiple instances of the annotator(s), and runs each one on its own thread, all
                    drawing work from the same input queue.</p></li><li class="listitem">
                  <p>(For AS Aggregates) connections to input queues of the delegates</p></li><li class="listitem">
                  <p>A "pull" mechanism for the component to pull new CASes (to be processed) from
                    their associated input queue </p></li><li class="listitem">
                  <p>(For AS Aggregates) A separate, built-in internal queue to receive CASes back from
                    delegates. These are passed to the aggregate's flow controller, which then specifies where
                    they go next.</p></li><li class="listitem">
                  <p>A connection to user-specified error handlers. Error conditions are communicated to the
                    flow controller, to enable user / dynamically determined recovery or termination
                    actions.</p></li></ul></div></li></ol></div><p> </p>
      <div class="figure"><a name="ugr.async.ov.fig.wrapAE"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="279"><tr><td><img src="images/uima_async_scaleout/async.overview/wrapAE.png" width="279" alt="AS Primitive Wrapper"></td></tr></table></div></div><p class="title"><b>Figure&nbsp;1.1.&nbsp;AS Primitive Wrapper</b></p></div><br class="figure-break">
      <p>As shown in the next figure, when the component being wrapped is an AS Aggregate, the container will use
        the aggregate's flow controller (shown as "FC") to determine the flow of the CASes among the
        delegates. The next figure shows the additional output queue configured for aggregates to receive CASes
        returning from delegates. The dashed lines show how the queues are associated with the components.</p>
      <div class="figure"><a name="ugr.async.ov.fig.wrapAAE"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="590"><tr><td><img src="images/uima_async_scaleout/async.overview/wrapAAE.png" width="590" alt="AS Aggregate Container wrapping an Aggregate Analysis Engine"></td></tr></table></div></div><p class="title"><b>Figure&nbsp;1.2.&nbsp;AS Aggregate wrapper</b></p></div><br class="figure-break">
      <p>The collection of parts and queues is wired together according to a deployment specification, provided
        by the deployer. This specification is a collection of one or more deployment descriptors.</p>
    </div>
    
    
    <div class="section" title="1.4.3.&nbsp;Parallel Flows"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.parallelFlows">1.4.3.&nbsp;Parallel Flows</h3></div></div></div>
      
      <p>A Flow Controller Parallel Step will actually run in parallel, when using remote
      delegates with xmi serialization (the default) sepecified.  
      For colocated delegates, or for remote delegates running with binary serialization, 
      the parallel steps will be run serially in some arbitrary unspecified order.
      For the parts running in parallel on remotes, 
      existing Feature Structures may not be modified - only new ones can be added.  
      This is checked for, when the 
      results from the remote parallel steps are merged.</p>
    </div>
    
    
    
    <div class="section" title="1.4.4.&nbsp;Deployment alternatives"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.deploying">1.4.4.&nbsp;Deployment alternatives</h3></div></div></div>
      
      <p>Deployment is concerned with the following kinds of parts, and allocating these parts (possibly
        replicated) to various hosts:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p>Application Drivers. These represent the top level caller of UIMA functionality. Examples
              include: stand-alone Java applications, such as the example document analyzer tool, a custom Web
              servlet, etc. </p></li><li class="listitem">
            <p>AS Services. AS primitive or AS aggregate services deployed on one or more nodes as needed to meet
              scalability requirements.</p></li><li class="listitem">
            <p>Queue Brokers. Each Queue Broker manages and provides the storage facility for one or more named
              queues. </p></li></ul></div><p> </p>
      <p>Parts can be co-located or not; when they're not, we say they're remote. Remote includes running on the
        same host, but in a different process space, using a different JVM or other native process. Connections
        between the non-co-located parts are done using the JMS (Java Messaging Service) protocols, 
        using ActiveMQ from apache.org.</p> 
          
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>          
        <p>For high availability, the Queue Brokers can be, themselves, replicated over many hosts, with
          fail-over capability provided by the underlying ActiveMQ implementation.</p></div>
      
      
      
      <div class="section" title="1.4.4.1.&nbsp;Configuring multiple instances of components"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.deploying.multiples">1.4.4.1.&nbsp;Configuring multiple instances of components</h4></div></div></div>
        
        
        <p>AS components can be replicated; the replicated components can be co-located or distributed across
          different nodes. The purpose of the replication is to allow multiple work units (CASes) to be processed in
          parallel, in multiple threads, either in the same host, or using different hosts. The vision is that the
          deployment is able to replicate just those components which are the bottleneck in overall system thruput.
          </p>
        <p>There are two ways replication can be specified.
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
              <p>In the deployment descriptor, for an AS Primitive component, 
                set the numberOfInstances attribute of the &lt;scaleout&gt; element to a number bigger than
                one.</p></li><li class="listitem">
              <p>Deploy the same service on many nodes, specifying the same input service queue</p>
            </li></ol></div>
        <p>The first way is limited to replicating an AS Primitive. An AS Primitive can be the whole component of
          the service, or it can be at the bottom of an aggregate hierarchy of co-located parts. </p>
        <p>Replicating an AS Primitive has the effect of replicating all of its nested components (if it is an aggregate), 
          since no queues are
          used below its input queue. </p></div>
      
      
      
      <div class="section" title="1.4.4.2.&nbsp;Queues"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.deploying.queues">1.4.4.2.&nbsp;Queues</h4></div></div></div>
        
        <p>Asynchronous operation uses queues to connect components.  For co-located components,
          the UIMA AS framework uses custom very-lightweight queuing mechanisms.  For non-co-located
          components, it uses JMS queues, managed by ActiveMQ Queue Brokers, which can be running
          on the other nodes in a network.
        </p>
        
        <p>AS Aggregate delegates specified as &lt;analysisEngine&gt; elements (or by default)
          are co-located, and use custom lightweight queuing.  AS Aggregate delegates specified using 
          &lt;remoteAnalysisEngine&gt; are not co-located, and use JMS queuing.</p>
        
        <p>For JMS queues, each queue is defined by a queue name and
          the URL of its Queue Broker. AS services register as queue consumers to obtain CASes to work on 
          (as input) and
          to send CASes they're finished with (as output) to a reply queue connected to the AS client.</p>
          
        <p>The queue implementation for JMS is provided by ActiveMQ queue
          broker. A single Queue Broker can manage multiple queues. 
          By default UIMA AS configures the Queue Broker to
          use in-memory queues; the queue is resident on the same JVM as its managing Queue Broker. ActiveMQ offers
          several failsafe options, including the use of disk-based queues and redundant master/slave broker
          configurations.</p>
          
        <p>The decisions about where to deploy Queue Brokers are deployment decisions, made based on issues such
          as domain of control, firewalls, CPU / memory resources, etc. Of particular interest for distributed
          applications is that a UIMA AS service can be deployed behind a firewall but still be publicly available by
          using a queue broker that is available publicly. </p>
          
        <p>When components are co-located, an optimization is done so that CASes are not actually sent as they
          would be over the network; rather, a reference to the in-memory Java object is passed using the queue.
          </p>
          
        <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
        <p>Do not hook up different kinds of services to the same input queue. The framework expects that multiple
          services all listening to a particular input queue are sharing the workload of processing CASes sent to
          that queue. The framework does not currently verify that all services on a queue are the same kind, but
          likely will in a future release.</p></div></div>
      
      
      
      <div class="section" title="1.4.4.3.&nbsp;Deployment Descriptors"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.deployment_descriptors">1.4.4.3.&nbsp;Deployment Descriptors</h4></div></div></div>
        
        <p>Each deployment descriptor specifies deployment information for one service, including all of its
          co-located delegates (if any). A service is an AS component, having one top level input queue, to which
          CASes are sent for processing.</p>
        <p>Each deployment descriptor has a reference to an associated Analysis Engine descriptor, which can be
          an aggregate, or a primitive (including CAS Consumers).</p>
        <p>AS Components can be co-located (this is the default); the
          deployment descriptor specifies
          remote queues (queue-brokers and queue-names) for non-co-located components.</p>
        
        <p>All services need to be manually started using an appropriate deployment descriptor (describing the
          things to be set up on that server). There are several scripts provided including deployAsyncService,
          that do this. The client API also supports a deploy method for doing this within the same JVM.</p>
        
        <div class="section" title="Deploying UIMA aggregates"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.ov.concepts.deployment_descriptors.aggregate">Deploying UIMA aggregates</h5></div></div></div>
          
          <p>UIMA aggregates can either be run asynchronously as AS Aggregates, or synchronously (as AS
            Primitives). AS Aggregates have an input and a reply queue associated with each delegate, and can
            process multiple CASes at a time. 
            UIMA aggregates that are run as AS Primitives send CASes synchronously, one a time, to each
            delegate, without using any queuing mechanism.</p>
            
          <p>Each delegate in an AS Aggregate can be specified to be local or remote. Local means co-located using
            internal queues; remote means all others, including delegates running in a different JVM, or
            in the same JVM but that can be shared by multiple clients.  
            For each delegate which is remote, the
            deployment descriptor specifies the delegate's input queue; a corresponding 
            reply queue is also automatically set up. 
            If the delegate is local, internal
            input and reply queues are automatically created for that delegate.</p></div>
        </div></div>
    
    
    
    
    <div class="section" title="1.4.5.&nbsp;Current design limitations"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.first_limits">1.4.5.&nbsp;Current design limitations</h3></div></div></div>
      
      
      <p>This section describes limitations of the current support for AS.</p>
      
      
      <div class="section" title="1.4.5.1.&nbsp;Sofa Mapping limits"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.first_limits.sofa_mapping">1.4.5.1.&nbsp;Sofa Mapping limits</h4></div></div></div>
        
        <p>Sofa mapping works for co-located delegates, only. As with Vinci and SOAP, remote delegates needing
          sofa mapping need to respecify sofa mappings in an aggregate descriptor at the remote node.</p>
      </div>
      <div class="section" title="1.4.5.2.&nbsp;Parameter Overriding limits"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.first_limits.parameter_overriding">1.4.5.2.&nbsp;Parameter Overriding limits</h4></div></div></div>
        
        <p>Parameter overrides only work for co-located delegates. As with Vinci and SOAP, remote delegates
          needing parameter overrides need to respecify the overrides in an aggregate descriptor at the remote
          node.</p></div>
      <div class="section" title="1.4.5.3.&nbsp;Resource Sharing limits"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.ov.concepts.first_limits.resource_sharing">1.4.5.3.&nbsp;Resource Sharing limits</h4></div></div></div>
        
        <p>Resource Sharing works for co-located delegates, only. </p></div>
        
      </div>
    <div class="section" title="1.4.6.&nbsp;Compatibility with earlier version of remoting and scaleout"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.first_limits.compatibility">1.4.6.&nbsp;Compatibility with earlier version of remoting and scaleout</h3></div></div></div>
      
      
      <p>There is a new type of client
        service descriptor for an AS service, the JMS service descriptor (see <a class="xref" href="#ugr.async.ov.concepts.jms_descriptor" title="1.7.&nbsp;JMS Service Descriptor">Section&nbsp;1.7, &#8220;JMS Service Descriptor&#8221;</a>), which can be used along with Vinci
        and/or SOAP services in base UIMA applications. Conversely, Vinci services
        <span class="bold"><strong>cannot</strong></span> be used within a UIMA AS service
        because they do not comply to the UIMA standard requiring preservation of feature
        structure IDs. SOAP service calls currently use a binary serialization of the CAS
        which does preserve IDs and therefore can be called from a UIMA AS service.
      </p>
      <p>To use SOAP services within a UIMA AS deployment, wrap them inside another aggregate
          (which might contain just the one SOAP service descriptor), where the wrapping aggregate
          is deployed as an AS Primitive.</p>
      </div></div>
  
  
  
  
  <div class="section" title="1.5.&nbsp;Application Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.concepts.application">1.5.&nbsp;Application Concepts</h2></div></div></div>
    
    <p>When UIMA is used, it is called using Application APIs. A typical top-level driver has this basic flow:
      </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
          <p>Read UIMA descriptors and instantiate components</p></li><li class="listitem">
          <p>Do a Run</p></li><li class="listitem">
          <p>Do another Run, etc.</p></li><li class="listitem">
          <p>Stop</p></li></ol></div><p>
       </p>
    <p>A "run", in turn, consists of 3 parts:
      </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
          <p>initialize (or reinitialize, if already run)</p></li><li class="listitem">
          <p>process CASes</p></li><li class="listitem">
          <p>finish (collectionProcessComplete is called)</p></li></ol></div><p> </p>
    <p>Initialize is called by the framework when the instance is created. The other methods need to be called by
      the driver. <code class="literal">collectionProcessComplete</code> should be called when the driver determines
      that it is finished sending input CASes for processing using the <code class="literal">process()</code> method.
      <code class="literal">reinitialize()</code> can be called if needed, after changing parameter settings, to get the
      co-located components to reinitialize. </p>
    <div class="section" title="1.5.1.&nbsp;Application API"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.application.api">1.5.1.&nbsp;Application API</h3></div></div></div>
      
      <p>See <a class="xref" href="#ugr.ref.async.api" title="Chapter&nbsp;4.&nbsp;Asynchronous Scaleout Application Interface">Chapter&nbsp;4, <i>Asynchronous Scaleout Application Interface</i></a>
        and the sample code.</p>
      </div>
    
    
    
    
    <div class="section" title="1.5.2.&nbsp;Collection Process Complete"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.ov.concepts.collection_process_complete">1.5.2.&nbsp;Collection Process Complete</h3></div></div></div>
      
      <p>An application may want to signal a chain of annotators that are being used in a 
        particular "run" when
        all CASes for this run have been processed, and any final computation and outputting is to be done; it calls the
        collectionProcessComplete method to do this. This is frequently done when using stateful components which
        are accumulating information over multiple documents. </p>
      <p>It is up to the application to determine when the run is finished and there are no more CASes to process. It
        then calls this method on the top level analysis engine; the framework propagates this method call to all
        delegates of this aggregate, and this is repeated recursively for all delegate aggregates. </p>
      <p>This call is synchronous; the framework will block
        the thread issuing the call until all processing of CASes within the service has completed and the
        collectionProcessComplete method has returned (or timed out) from every component it was sent to.
         </p>
      <p>Components receive this call in a fixed order taken from the &lt;fixedFlow&gt; sequence information in
        the descriptors, if that is available, and in an arbitrary order otherwise.</p>
      <p>If a component is replicated, only one of the instances will receive the collectionProcessComplete
        call.
         </p>
      
      
      
      </div></div>
  
  
  
  <div class="section" title="1.6.&nbsp;Monitoring and Controlling an AS application"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.concepts.mc">1.6.&nbsp;Monitoring and Controlling an AS application</h2></div></div></div>
    
    
    <p>JMX (Java Management Extensions) are used for monitoring and controlling an AS application.
      As of release 2.3.0, extensive monitoring facilities have been implemented; these are described
      in a separate chapter on <a class="xref" href="#ugr.async.mt" title="Chapter&nbsp;5.&nbsp;Monitoring, Tuning and Debugging">Chapter&nbsp;5, <i>Monitoring, Tuning and Debugging</i></a>.
      The only controlling facility provided is to stop a service.</p>
    
           <p>In addition, a configurable Monitoring program is provided which works with the JMX provided measurements
            and aggregates and samples these over specified intervals, and creates monitoring entries in the
            UIMA log, for tuning purposes.  You can use this to detect overloaded and/or idle services;
            see the <a class="xref" href="#ugr.async.mt" title="Chapter&nbsp;5.&nbsp;Monitoring, Tuning and Debugging">Chapter&nbsp;5, <i>Monitoring, Tuning and Debugging</i></a> chapter for details.</p>
         

           
  </div>
  
  
  
  <div class="section" title="1.7.&nbsp;JMS Service Descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.concepts.jms_descriptor">1.7.&nbsp;JMS Service Descriptor</h2></div></div></div>
    
    <p>To call a UIMA AS Service from Document Analyzer or any other base UIMA application, use a descriptor such as
      the following: </p>
    
    
    <pre class="programlisting">
&lt;customResourceSpecifier xmlns="http://uima.apache.org/resourceSpecifier"&gt;
  &lt;resourceClassName&gt;
    org.apache.uima.aae.jms_adapter.JmsAnalysisEngineServiceAdapter
  &lt;/resourceClassName&gt;
  &lt;parameters&gt;
    &lt;parameter name="brokerURL" 
               value="tcp://uima17.watson.ibm.com:61616"/&gt;
    &lt;parameter name="endpoint" 
               value="uima.as.RoomDateMeetingDetectorAggregateQueue"/&gt;
    &lt;parameter name="timeout" 
               value="xxx"/&gt;  
    &lt;parameter name="getmetatimeout" 
               value="yyy"/&gt;
    &lt;parameter name="cpctimeout" 
               value="zzz"/&gt;
  &lt;/parameters&gt;
&lt;/customResourceSpecifier&gt;</pre>
    
    <p>The resourceClassName must be set exactly as shown. Set the brokerURL and endpoint parameters to the
      appropriate values for the UIMA AS Service you want to call. These are the same settings you would use in a
      deployment descriptor to specify the location of a remote delegate. Note that this is a synchronous adapter,
      which processes one CAS at a time, so it will not take advantage of the scalability that UIMA AS provides. To
      process more than one CAS at a time, you must use the Asynchronous UIMA AS Client API 
      <a class="xref" href="#ugr.ref.async.api" title="Chapter&nbsp;4.&nbsp;Asynchronous Scaleout Application Interface">Chapter&nbsp;4, <i>Asynchronous Scaleout Application Interface</i></a>.</p>
    
    <p>The three timeouts are all expressed in milliseconds.  The getmetatimeout is typically short, but if the
    service is just starting, and initialization takes a while, it may need to be longer, because the service
    won't reply to the getmeta request until it is finished initializing.  
    The cpctimeout is the Collection Processing Complete
    timeout.  Defaults are taken if the value is omitted, or is 0.</p>
      
    <p>Other parameters may be specified:
      </p><div class="variablelist"><dl><dt><span class="term">binary_serialization</span></dt><dd>
            <p>Set to true to specify binary serialization (faster, but requires that the service
              have exactly the same type system as the client). The default is false =&gt; XMI serialization.
            </p>
          </dd><dt><span class="term">ignore_process_errors</span></dt><dd>
            <p>Set to true to specify that any processing errors should be ignored.  In order for this
              to be reasonable, your calling environment must be able to continue somehow,
              if the service fails. The default is false.
            </p>
          </dd><dt><span class="term">retry</span></dt><dd>
            <p>Set to the number of times to retry the process call in case of errors. The default is
            0 =&gt; no retries.
            </p>
          </dd></dl></div><p>
      </p>
    <p>For more information on the customResourceSpecifier see <a href="references.html#ugr.ref.xml.component_descriptor.custom_resource_specifiers" class="olink">Section&nbsp;2.8, &#8220;Custom Resource Specifiers&#8221;</a>. </p>
  </div>
  
  <div class="section" title="1.8.&nbsp;Life cycle"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.ov.concepts.lifecycle">1.8.&nbsp;Life cycle</h2></div></div></div>
    
    
    <p>Running UIMA AS applications involves deploying (starting) UIMA AS services, perhaps over a wide area
      network, perhaps on many machines.  UIMA AS as a few preliminary tools to help.  These include the ability
      of the <a class="xref" href="#ugr.ref.async.api" title="Chapter&nbsp;4.&nbsp;Asynchronous Scaleout Application Interface">Chapter&nbsp;4, <i>Asynchronous Scaleout Application Interface</i></a> to deploy UIMA AS services (limited to deployment within the same 
      JVM), and scripts such as <code class="code">deployAsyncService</code> that start up a UIMA AS Service.</p>
        
    <p><code class="code">deployAsyncService</code> has a facility that launches a keyboard listener after starting, which 
      listens for a "s" or "q" keystroke.  The "s" stops the service immediately, and the "q" quiesces the service,
      letting any in-process work finish before stopping.</p>
      
    <p>JMX beans for services include a control option to stop the service.</p>
  </div>
  
  
  
  </div>
  <div class="chapter" title="Chapter&nbsp;2.&nbsp;Error Handling for Asynchronous Scaleout" id="ugr.async.eh"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Error Handling for Asynchronous Scaleout</h2></div></div></div>
  
  <p>This chapter discusses the high level architecture for Error Handling from the user's point of view. </p>
  <div class="section" title="2.1.&nbsp;Basic concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.basic">2.1.&nbsp;Basic concepts</h2></div></div></div>
    
    <p>This chapter describes error configuration for AS components.</p>
    <p>The AS framework manages a collection of component parts written by users (user code) which can throw
      exceptions. In addition, the AS framework can run timers when sending commands to user code which can create
      timeouts.</p>
    <p>An AS component is either an AS aggregate or an AS primitive. AS aggregates can have multiple levels of
      aggregation; error configuration is done for each level of aggregation. The rest of this chapter focuses on the
      error configuration one level at a time (either for one particular level in an aggregate hierarchy, or for an AS
      primitive). </p>
    <p>There is a small number of commands which can be sent to an AS component. When a component returns the result,
      if an error occurs, an error result is returned instead of the normal result.</p>
    <p>Configuration and support is provided for three classes of errors: </p>
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>Exceptions thrown from code (component or framework) at this level</p></li><li class="listitem">
        <p>error messages received from delegates.</p></li><li class="listitem">
        <p>timeouts of commands sent to delegates.</p></li></ol></div>
    <p>The second and third class of errors is only possible for AS aggregates.</p>
    <p>When errors happen, the framework provides a standard set of configurable actions. See <a class="xref" href="#ugr.async.eh.commands_allowed_actions" title="2.8.&nbsp;Commands and allowed actions">Section&nbsp;2.8, &#8220;Commands and allowed actions&#8221;</a> for a summary table of the actions available
      in different situations.</p></div>
      
  <div class="section" title="2.2.&nbsp;Associating Errors with incoming commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.incoming_commands">2.2.&nbsp;Associating Errors with incoming commands</h2></div></div></div>
    
    <p>Components managed by AS may generate errors when they are sent a command. The error is associated with the
      command that was running to produce the error. </p>
    
    <p>There are three incoming message commands supported by the AS framework:
      </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
          <p>getMetadata - sent by the framework when initializing connection to an AS component</p>
          </li><li class="listitem">
          <p>processCas - sent once for each CAS</p></li><li class="listitem">
          <p>collectionProcessComplete - sent when an application calls this method</p></li></ol></div><p> </p>
    
    <p>Error handling actions are associated with these various commands. Some error handling actions make
      sense only if there is an associated CAS object, and are therefore only allowed with the processCas command.
      </p>
      
    <div class="section" title="2.2.1.&nbsp;Error handling for CASes generated in an Aggregate by CAS Multipliers"><div class="titlepage"><div><div><h3 class="title" id="ugr.asynch.eh.cas_multipliers">2.2.1.&nbsp;Error handling for CASes generated in an Aggregate by CAS Multipliers</h3></div></div></div>
      
       
      <p>
        CASes that are generated by a CAS Multiplier are called child CASes, and their parent CAS is the
        CAS that originally came into the CAS Multiplier which caused the child CASes to be created.
        Each child CAS always has one associated parent CAS.
      </p>
      
      <p>
        The flow of CASes is constrained to always block returning the parent CAS until all of its 
        children have been generated by the CAS Multiplier.  In addition, the framework (currently) blocks
        the flow of the parent CAS until all of its children have finished all processing, including
        any processing of the children in outer, containing aggregates (which can even be on other
        network-connected nodes).  (There is some discussion about relaxing this condition, to allow
        more asynchronicity.)  
      </p>
      
      <p>
        A child CAS may only exist for a part of the flow, and not returned all the way back
        up to the top.  Because of this, errors which occur on a child CAS and are 
        not recovered are reported on both the child CAS, and on its parent.  The parent
        CAS is not processed further, and an error is reported against the parent. 
      </p>
      
      <p>
        The parent CAS may have other outstanding children currently being processed.  It is not
        yet specified what happens (if anything) to these CASes.
      </p>
    </div>    
      
  </div>
  <div class="section" title="2.3.&nbsp;Error handling overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.error_handling_overview">2.3.&nbsp;Error handling overview</h2></div></div></div>
    
    <p>When an error happens, it is either "recovered", or not; only errors from delegates of an AS
      aggregate can be recovered. Recovery may be achieved by retrying the request or by skipping the
      delegate.</p>
    <p>Commands normally return results; however if an non-recoverable error occurs, the command returns an
      error result instead. </p>
    <p>For AS aggregates, each level in aggregate hierarchy can be configured to try to recover the error. If a
      particular AS aggregate level does not recover, the error is sent up to the next level of the hierarchy (or to the
      calling client, if a top level). The error result is updated to reflect the actions the framework takes for this
      error. </p>
    <p>Non-recovered errors can optionally have an associated "Terminate" or
      "Disable" action (see below), triggered by the error when a threshold is reached. "Disable"
      applies to the delegate that generated the error while "Terminate" applies to the aggregate and any co-located
      aggregates it is contained within.</p>
    
    <div class="figure"><a name="ugr.async.eh.fig.basic_eh_chain"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="444"><tr><td><img src="images/uima_async_scaleout/async.errorhandling/error_chain_aggr.png" width="444" alt="Basic error handling chain for aggregates"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.1.&nbsp;Basic error handling chain for AS Aggregates for errors from delegates</b></p></div><br class="figure-break">
    
    <p>The basic error handling chain starts with an error, and can attempt to recover using retry. If this fails
      (or is not configured), the error count is incremented and checked against the thresholds for this delegate. If
      the threshold has been reached the specified action is taken, disabling the delegate or terminating the entire
      component. If the Terminate error is not taken, recovery by the Continue action can be attempted. If that fails,
      an error result is returned to the caller. </p>
    <p>For AS primitives, only the Terminate action is available, and Retry and Continue do not apply.</p>
    
    <div class="figure"><a name="ugr.async.eh.fig.basic_eh_chain_prim"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="330"><tr><td><img src="images/uima_async_scaleout/async.errorhandling/error_chain_prim.png" width="330" alt="Basic error handling chain for aggregates"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.2.&nbsp;Basic error handling chain for AS Primitives</b></p></div><br class="figure-break">
    
  </div>
  
  <div class="section" title="2.4.&nbsp;Error results"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.error_results">2.4.&nbsp;Error results</h2></div></div></div>
    
    <p>Error results are returned instead of a CAS, if an error occurs and is not recovered.</p>
    <p>If the application uses the synchronous sendAndReceive() method, an Error Result is passed back to the
      client API in the form of a Java exception. The particular exception varies, depending on many factors, but will
      include a complete stack trace beginning with the cause of the error. If the application uses an asynchronous
      API, the exception is wrapped in a EntityProcessStatus object and delivered via a callback listener
      registered by the application. See section 4.4 Status Callback Listener for details.</p>
  </div>
  
  <div class="section" title="2.5.&nbsp;Error Recovery actions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.aggregate_managed">2.5.&nbsp;Error Recovery actions</h2></div></div></div>
    
    <p>When errors occur in delegates, the aggregate containing them can attempt to recover. There are two basic
      recovery actions: retrying the same command and continuing past (skipping) the failing component.</p>
    
    <p>Every command sent to a delegate can have an associated (configurable) timeout. If the timeout occurs
      before the delegate responds, the framework creates an error representing the timeout.
      </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>If, subsequently, a response is (finally) received corresponding to the command that had timed-out,
          this is logged, but the response is discarded and no further action is taken.
        </p>
      </div><p> 
    </p>
    
    <p>When errors occur in delegates, retry is attempted (if configured), some number of times. If that fails,
      error counts are incremented and thresholds examined for Terminate/Disable actions. If not reached, or if the
      action is Disable, Continue is attempted (if configured); if Continue fails, the error is not recovered, and
      the aggregate returns the error result from the delegate to the aggregate's caller. On Terminate, the error is
      returned to the caller.</p>
    
  <div class="section" title="2.5.1.&nbsp;Aggregate Error Actions"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.eh.aggregate_managed.actions">2.5.1.&nbsp;Aggregate Error Actions</h3></div></div></div>
    
    <p>This section describes in more detail the error actions valid only for AS aggregates.</p>
    <div class="section" title="2.5.1.1.&nbsp;Retry"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.eh.aggregate_managed.actions.retry">2.5.1.1.&nbsp;Retry</h4></div></div></div>
      
      <p>Retry is an action which re-sends the same command that failed back to the input queue of the delegate. (Note: It may be picked 
        up by a different instance of that delegate, which may have a better chance of succeeding.) The framework will keep a copy of the 
        CAS sent to remote components in order to have it to send again if a retry is required. </p>
      <p>
        <span class="bold"><strong>Retry is not allowed for colocated delegates.</strong></span>
      </p>
      <p>The "collectionProcessComplete" command is never retried.</p>
      <p>Retry is done some number of times, as specified in the deployment descriptor.</p>
    </div>
    
    <div class="section" title="2.5.1.2.&nbsp;Disable Action"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.eh.aggregate_disable">2.5.1.2.&nbsp;Disable Action</h4></div></div></div>
      
      <div class="figure"><a name="ugr.async.eh.fig.disable"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="206"><tr><td><img src="images/uima_async_scaleout/async.errorhandling/disable_action.jpg" width="206" alt="Disable Action"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.3.&nbsp;Disable action</b></p></div><br class="figure-break">
      <p>When this action is taken the framework marks the particular delegate causing the error as "disabled" so it will be 
        skipped in subsequent calls. The framework calls the flow controller, telling it to remove the particular delegate from the flow. 
        </p>
    </div>
    <div class="section" title="2.5.1.3.&nbsp;Continue Option on Delegate Process CAS Failures"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.eh.aggregate_managed.actions.continue">2.5.1.3.&nbsp;Continue Option on Delegate Process CAS Failures</h4></div></div></div>
      
      <p>For processCas commands, the Continue action causes the framework to give the flow controller object for that CAS the error 
        details, and ask the flow controller if processing can continue. If the flow controller returns "true", the flow 
        controller will be called asking for the next step; if "false", the framework stops processing the CAS, returning an 
        error to the client reply queue, or just returning the CAS to the casPool of the CAS multiplier which created it.</p>
      <p>For "collectionProcessComplete" commands, Continue means to ignore the error, and continue as if the 
        collectionProcessComplete call had returned normally. </p>
      <p>This action is not allowed for the getMetadata command.</p>
    </div>
    
  </div>
    </div>
  
  
  
  <div class="section" title="2.6.&nbsp;Thresholds for Terminate and Disable"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.errors_passed_up.thresholds">2.6.&nbsp;Thresholds for Terminate and Disable</h2></div></div></div>
    
    <p>The Terminate and Disable actions are conditioned by testing against a threshold.</p>
    <p>Thresholds are specified as two numbers - an error count and a window. The threshold is reached if the number
      of errors occurring within the window size is equal to or greater than "the error count". A value of 0
      disables the error threshold so no action can be taken. A window of 0 means no window, i.e. all errors are
      counted</p>
    <p>Errors associated with the processCas command are the only ones that are counted in the threshold
      measurements.</p></div>
  <div class="section" title="2.7.&nbsp;Terminate Action"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.terminate">2.7.&nbsp;Terminate Action</h2></div></div></div>
    
    <p>When this action is taken the service represented by this component sends an error reply and then
      terminates, disconnecting itself as a listener from its input queue, and cleaning itself up (releasing
      resources, etc.). During cleanup, the component analysis engine's <code class="literal">destroy</code> method is
      called.</p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The termination action applies to the entire aggregate service. Remote delegates are not
    affected.</p></div>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>By default, the service will self-destruct by calling System.exit(0) if the shutdown doesn't finish
    within 40 seconds. To disable calling System.exit(0) define System property -DdontKill=true.</p></div>
    
    <div class="figure"><a name="ugr.async.eh.fig.terminate"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="206"><tr><td><img src="images/uima_async_scaleout/async.errorhandling/terminate_action.jpg" width="206" alt="Terminate Action"></td></tr></table></div></div><p class="title"><b>Figure&nbsp;2.4.&nbsp;Terminate action</b></p></div><br class="figure-break">
    <p>If the threshold is not exceeded, the error counts associated with the threshold are incremented.</p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    <p>Some errors will always cause a terminate: for instance, framework or flow controller errors cause
      immediate termination.</p></div></div>
  
  
  
  <div class="section" title="2.8.&nbsp;Commands and allowed actions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.eh.commands_allowed_actions">2.8.&nbsp;Commands and allowed actions</h2></div></div></div>
    
    <p>All of the allowed actions are optional, and default to not being done, except for getMetadata being sent to
      a delegate that is remote - this has a default timeout of 1 minute. </p>
    <p>Here's a table of the allowed actions, by command. In this table, the Retry, Continue, and Disable actions
      apply to the particular Delegate associated with the error; the Terminate action applies to the entire
      component.</p>
    <p>The framework returns an Error Result to the caller for errors that are not recovered.</p>
    <div class="table"><a name="ugr.async.eh.table.error_actions_by_command"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Error actions by command type</b></p><div class="table-contents">
      
      <table summary="Error actions by command type" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="col1"><col class="col2"><col class="col3"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; " rowspan="2" valign="middle">Command</th><th style="border-bottom: 0.5pt solid black; " colspan="2" align="center">Error actions allowed</th></tr><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">AS Aggregate</th><th style="border-bottom: 0.5pt solid black; ">AS Primitive</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">getMetadata</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Retry, Disable, Terminate</td><td style="border-bottom: 0.5pt solid black; ">Terminate</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">processCas</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Retry, Continue, Disable, Terminate</td><td style="border-bottom: 0.5pt solid black; ">Terminate</td></tr><tr><td style="border-right: 0.5pt solid black; ">collection Processing Complete</td><td style="border-right: 0.5pt solid black; ">Continue, Disable, Terminate</td><td style="">Terminate</td></tr></tbody></table></div></div><br class="table-break">
    <p>The rationale for providing the terminate action for primitive services is that only the service can know
      that it is no longer capable of continued operation. Consider a scaled component with multiple service
      instances, where one of them goes "bad" and starts throwing exceptions: the clients of this service
      have no way of stopping new requests from being delivered to this bad service instance. The teminate action
      allows the bad service to remove itself from further processing; this could allow life cycle management to
      restart a new instance. </p>
  </div>
  
  
  
  
  
  
  
</div>
  <div class="chapter" title="Chapter&nbsp;3.&nbsp;Asynchronous Scaleout Deployment Descriptor" id="ugr.ref.async.deploy"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;Asynchronous Scaleout Deployment Descriptor</h2></div></div></div>
  
  
  <div class="section" title="3.1.&nbsp;Descriptor Organization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor_organization">3.1.&nbsp;Descriptor Organization</h2></div></div></div>
    
    <p> Each deployment descriptor describes one service, associated with a single UIMA descriptor (aggregate
      or primitive), and describes the deployment of those UIMA components that are co-located, together with
      specifications of connections to those subcomponents that are remote. </p>
    
    <p> The deployment descriptor is used to augment information contained in an analysis engine descriptor. It
      adds information concerning
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>which components are managed using AS</p></li><li class="listitem"><p>queue names for connecting components</p></li><li class="listitem"><p>error thresholds and recovery / terminate action specifications</p></li><li class="listitem"><p>error handling routine specifications</p></li></ul></div><p> </p>
    
    <p>The application can include both Java and non-Java components; the deployment descriptors are slightly
      different for non-Java components.</p>
    
  </div>
  
  
  
  
  <div class="section" title="3.2.&nbsp;Deployment Descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor">3.2.&nbsp;Deployment Descriptor</h2></div></div></div>
    
    
    <p>Each deployment descriptor describes components associated with one UIMA descriptor. The basic
      structure of a Deployment Descriptor is as follows:
      
      
      </p><pre class="programlisting">
&lt;analysisEngineDeploymentDescription 
      xmlns="http://uima.apache.org/resourceSpecifier"&gt;

  &lt;!-- the standard (optional) header --&gt;
  &lt;name&gt;[String]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;

  &lt;deployment protocol="jms" provider="activemq"&gt;

    &lt;casPool numberOfCASes="xxx" initialFsHeapSize="nnn"/&gt;

    &lt;service&gt;         &lt;!-- must have only 1 --&gt;

      &lt;!-- 0 or more of the following --&gt;
      &lt;!-- name required, value optional --&gt;
      &lt;custom name="..." value="..."/&gt;

      &lt;inputQueue .../&gt;

      &lt;topDescriptor .../&gt; 

      &lt;environmentVariables .../&gt;  &lt;!--optional --&gt;

      &lt;analysisEngine key="key name" async="[true/false]"
             internalReplyQueueScaleout="nn1" &lt;!-- optional --&gt;
             inputQueueScaleout="nn2"&gt;        &lt;!-- optional --&gt;

        &lt;scaleout numberOfInstances="1"/&gt;       &lt;!-- optional --&gt;
                                                &lt;!-- optional --&gt; 
        &lt;casMultiplier 
             poolSize="5"                       &lt;!-- optional --&gt; 
             initialFsHeapSize="nnn"            &lt;!-- optional --&gt;
             processParentLast="[true/false]"/&gt; &lt;!-- optional --&gt;
             
        &lt;asyncPrimitiveErrorConfiguration .../&gt; &lt;!-- optional --&gt;

        &lt;delegates&gt;    &lt;!-- optional, only for aggregates --&gt;
                                       &lt;!-- 0 or more --&gt;
          &lt;analysisEngine key="key name" async="[true/false]"
               internalReplyQueueScaleout="nn1"
               inputQueueScaleout="nn2"&gt;
  
                ...    &lt;!-- optional nested specifications --&gt;
          &lt;/analysisEngine&gt;
                . . .
          &lt;remoteAnalysisEngine key="key name"  &lt;!-- 0 or more --&gt;
               remoteReplyQueueScaleout="nn1"&gt;  &lt;!-- optional --&gt;
  
            &lt;!-- next is either required or must be omitted --&gt;
            &lt;casMultiplier 
                    poolSize="5" 
                    initialFsHeapSize="nnn"
                    processParentLast="[true/false]"/&gt; &lt;!-- optional --&gt;
                    
            &lt;inputQueue ... /&gt;
            &lt;serializer method="xmi"/&gt;
            &lt;asyncAggregateErrorConfiguration ... /&gt;
          &lt;/remoteAnalysisEngine&gt;
                . . .
        &lt;/delegates&gt;
      &lt;/analysisEngine&gt;
    &lt;/service&gt; 
  &lt;/deployment&gt;
&lt;/analysisEngineDeploymentDescription&gt;</pre>
    </div>
  
  
  
  <div class="section" title="3.3.&nbsp;CAS Pool"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.caspool">3.3.&nbsp;CAS Pool</h2></div></div></div>
    
    <p>This element specifies information for managing CAS pools. Having more CASes in the pools enables more AS
      components to run at the same time. For instance, if your application had four components, but one was slow, you
      might deploy 10 instances of the slow component. To get all 10 instances working on CASes simultaneously, your
      CAS pool should be at least 10 CASes. The casPool size should be small enough to avoid paging.</p>
    
    <p>The initialFsHeapSize attribute is optional, and allows setting the size of the initial CAS Feature
      Structure heap. This number is specified in bytes, and the default is approximately 2 megabytes for Java
      top-level services, and 40 kilobytes for C++ top level services. The heap grows as needed; this parameter is
      useful for those cases where the expected heap size is much smaller than the default.</p>
    
    
    
  </div>
  
  
  
  
  
  
  
  
  <div class="section" title="3.4.&nbsp;Service"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.service">3.4.&nbsp;Service</h2></div></div></div>
    
    <p> This section is required and specifies the deployment information for the service.</p>
  </div>
  
  
  
  
  <div class="section" title="3.5.&nbsp;Customizing the deployment"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.custom">3.5.&nbsp;Customizing the deployment</h2></div></div></div>
    
    <p>The &lt;custom&gt; element(s) are optional. Each one, if specified, requires a name parameter, and can have
      an optional value parameter. They are intended to provide additional information needed for particular kinds
      of deployment. </p>
    
    <p>The following lists the things that can be specified here.</p>
    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p> name="run_top_level_CPP_service_as_separate_process"</p>
        <p>(no value used)</p>
        <p>Causes the top level component, which must be a component specified as using
          &lt;frameworkImplementation&gt;org.apache.uima.cpp&lt;/frameworkImplementation&gt; and which must be
          specified as async="false" (the default), to be run in a separate process, rather than via using the
          JNI.</p>
      </li></ul></div>
  </div>
  
  
  
  
  <div class="section" title="3.6.&nbsp;Input Queue"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.input_queue">3.6.&nbsp;Input Queue</h2></div></div></div>
    
    <p>The inputQueue element is required. It identifies the input queue for the service. </p>
    
    
    <pre class="programlisting">&lt;inputQueue brokerURL="tcp://x.y.z:portnumber"
    endpoint="queue_name"
    prefetch="1"/&gt;</pre>
    
    <p>
    The brokerURL attribute is optional. When omitted, a default value of tcp://localhost:61616 will be used. 
    A different brokerURL can be provided as an override when launching a service. Consult README that provides
    an example of brokerURL override. The queue broker address includes a protocol specification, which should be set to either "tcp", or
      "http". The brokerURL attribute specifies the queue broker URL, typically its network address and
      port.
      .</p>
    
    <p>The http protocol is similar to the tcp protocol, but is preferred for wide-area-network connections
      where there may be firewall issues, as it supports http tunnelling.
      </p>
     
    
    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>When remote delegates are being used, 
     
      the brokerURL value used for this remote delegate is used also for the remote reply Queue, and must be valid
    for both the client to send requests and the remote service to send replies to. The URL to use for the reply is
    resolved on the remote system when sending a reply. Using "localhost" will not work, nor will partially specified
    URLs unless they resolve to the same URL on all nodes where services are running. The recommended best practice is
    to use fully qualified URL names.</p></div>
    
    <p>The queue name is used to uniquely identify a queue belonging to a particular broker.</p>
    
    <p> The <code class="literal">prefetch</code> attribute controls prefetching of messages for an instance of the
      service. It can be 0 - which disables prefetching. This is useful in some realtime applications for reducing
      latency. In this case, when a new request arrives, any available instance will take the request; if prefetching
      was set above 0, the request might be prefetched by a busy service. The default value if not specified is 0.
      </p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="literal">prefetch</code> attribute is only used with the top inputQueue element for the
    service.</p></div>
    
    
    
    
  </div>
  
  
  
  
  <div class="section" title="3.7.&nbsp;Top level Analysis Engine descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.top_descriptor">3.7.&nbsp;Top level Analysis Engine descriptor</h2></div></div></div>
    
    
    <p>Each service must indicate some analysis engine to run, using this element. </p>
    
    
    <pre class="programlisting">&lt;topDescriptor&gt;
  &lt;import location="..." /&gt; &lt;!-- or name="..." --&gt;
&lt;/topDescriptor&gt;</pre>
    <p> This is the standard UIMA import element. Imports can be by name or by location; see <a href="references.html#ugr.ref.xml.component_descriptor.imports" class="olink">Section&nbsp;2.2, &#8220;Imports&#8221;</a>. </p>
  </div>
  
  
  
  
  <div class="section" title="3.8.&nbsp;Setting Environment Variables"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.environment_variables">3.8.&nbsp;Setting Environment Variables</h2></div></div></div>
    
    <p>This element is optional, and provides a way to set environment variables.</p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This element is only allowed and used for top level Analysis Engines specifying
    &lt;frameworkImplementation&gt;org.apache.uima.cpp&lt;/frameworkImplementation&gt; and running using the
    &lt;custom name="run_top_level_CPP_service_as_separate_process"&gt;; it is not supported for Java Analysis
    Engines.</p></div>
    
    <p>Components written in C++ can be run as a top level service. These components are launched in a separate
      process, and by default, all the environment variables of the launching process are passed to the new process.
      This element allows the environment variables of the new process to be augmented. </p>
    
    
    <pre class="programlisting">&lt;environmentVariables&gt;
&lt;!-- one or more of the following element --&gt;
&lt;environmentVariable name="xxx"&gt;value goes here&lt;/environmentVariable&gt;
&lt;/environmentVariables&gt;</pre>
    <p> Usually, the value will replace any existing value. As a special exception, for the environment variables
      used as the PATH (for Windows) or LD_LIBRARY_PATH (for Linux) or DYLD_LIBRARY_PATH (for MacOS), the value will
      be "prepended" with a path separator character appropriate for the platform, to any existing value. </p>
  </div>
  
  
  
  
  <div class="section" title="3.9.&nbsp;Analysis Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.ae">3.9.&nbsp;Analysis Engine</h2></div></div></div>
    
    
    <p>This is used to describe an element which is an analysis engine. It is optional and only needed if the
      defaults are being overridden. The <code class="literal">async</code> attribute is only used for aggregates, and
      specifies that this aggregate will be run asynchronously (with input queues in front of all of its delegates) or
      not. If not specified, the async property defaults to "false" except in the case where the deployment
      descriptor includes the &lt;delegates&gt; element, when it defaults to "true". If you specify async="false",
      then it is an error to specify any &lt;delegates&gt; in the deployment descriptor. </p>
    
    
    <p>The <code class="literal">key</code> attribute must have as its value the key name used in the containing aggregate
      descriptor to uniquely identify this delegate. Since the top level aggregate is not contained in another
      aggregate, this can be omitted for that element. Deployment information is matched to delegates using the key
      name specified in the aggregate descriptor to identify the delegate. </p>
    
    
    <pre class="programlisting">&lt;analysisEngine key="key name" async="true"
             internalReplyQueueScaleout="nn1"  &lt;!-- optional --&gt;
             inputQueueScaleout="nn2"&gt;         &lt;!-- optional --&gt;

  &lt;scaleout numberOfInstances="1"/&gt;        &lt;!-- optional  --&gt;
  &lt;!-- casMultiplier is either required, or must be omitted--&gt;
  &lt;casMultiplier 
       poolSize="5"                        &lt;!-- optional  --&gt;
       initialFsHeapSize="nn"              &lt;!-- optional  --&gt;   
       processParentLast="[true/false]"/&gt;  &lt;!-- optional  --&gt;             

    &lt;!-- next two are optional, but only one allowed --&gt;
  &lt;asyncAggregateErrorConfiguration .../&gt;  &lt;!-- optional  --&gt;
  &lt;asyncPrimitiveErrorConfiguration .../&gt;  &lt;!-- optional  --&gt;

  &lt;delegates&gt;                              &lt;!-- optional  --&gt;
    &lt;analysisEngine key="key name" ...&gt;    &lt;!-- 0 or more --&gt;
            ...       &lt;!-- optional nested specifications --&gt;
    &lt;/analysisEngine&gt;
            . . . 
    &lt;remoteAnalysisEngine key="key name"   &lt;!-- 0 or more --&gt;
             remoteReplyQueueScaleout="nn1"&gt; &lt;!-- optional --&gt;

      &lt;!-- next is either required or must be omitted --&gt;
      &lt;casMultiplier 
           poolSize="5"                        &lt;!-- optional  --&gt;
           initialFsHeapSize="nnn"             &lt;!-- optional  --&gt;
           processParentLast="[true/false]"/&gt;  &lt;!-- optional  --&gt;             
      
      &lt;inputQueue ... /&gt;
      &lt;serializer method="[xmi|binary]"/&gt;              &lt;!-- optional --&gt;
      &lt;asyncAggregateErrorConfiguration .../&gt; &lt;!-- optional --&gt;
    &lt;/remoteAnalysisEngine&gt;
            . . . 
  &lt;/delegates&gt;                . . .        
&lt;/analysisEngine&gt;</pre>
    
    <p>&lt;analysisEngine&gt; is used to specify deployment details for an analysis engine. It is optional, and if
      omitted, defaults will be used: The analysis engine will be run synchronously
      (processing only one CAS at a time), with a scaleout of 1, using the
      default error configuration.</p>
    
    <p>
      The attributes <code class="code">internalReplyQueueScaleout</code> and <code class="code">inputQueueScaleout</code> only
      have meaning and are allowed when 
      async="true" is specified (which in turn can only be set true for aggregates) or is the default (
      which happens when the aggregate has delegate deployment options specified in the deployment descriptor).
      These attributes default to 1.  For asynchronous aggregates, they control the number of threads
      used to do the work of the aggregate outside of running the delegates.  This work can include
      one or more of the following:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>deserializing an input CAS (only on the input Queue),
          or serializing the resulting CAS back to a remote requester (only if the
          requester is remote).</p>
        </li><li class="listitem">
          <p>running the flow controller</p>
        </li><li class="listitem">
          <p>serializing CASes being sent to remote delegates (only useful if one or more
          of the delegates is remote).  
          </p>
        </li></ul></div><p>
      </p>
    
    <p>
      These attributes provide a way to scale out this work on multi-core machines, if these
      tasks become a bottleneck.
    </p>

    <p>Note that if an aggregates flow controller specifies
            that the first delegate the CAS should flow to is a remote, the work of serializing
            the CAS to that remote is done using the inputQueue thread, and the scaleout
            parameter that would apply would be the inputQueueScaleout.  For subsequent delegates,
            the work is done on the internalReplyQueueScaleout threads.
    </p>
    
    <p> The &lt;scaleout ...&gt; element specifies, for co-located primitive or non-AS aggregates
      (async="false") at the bottom of an aggregate tree, how many replicated instances are created.
      
      
      
      </p>
    
    <p>The &lt;casMultiplier&gt; element inside an &lt;analysisEngine&gt; element is required if the analysis
      engine component is a CAS multiplier, and is an error if specified for other components. It specifies for CAS
      multipliers the size of the pool of CASes used by that CAS multiplier for generating extra CASes.</p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The actual CAS pool size can be bigger than the size specified here. The custom CAS multiplier code
    specifies how many CASes it needs access to at the same time; the actual CAS pool size is the value in the deployment
    descriptor, plus the value in custom CM code, minus 1.</p></div>
    
    <p>The initialFsHeapSize attribute on the &lt;casMultiplier&gt; element is optional, and allows setting the
      size of the initial CAS Feature Structure heap for CASes in this pool. This number is specified in bytes, and the
      default is approximately 2 megabytes for Java top-level services, and 40 kilobytes for C++ top level services.
      The heap grows as needed; this parameter is useful for those cases where the expected heap size is much smaller
      than the default.</p>
    
    <p>The processParentLast attribute on the &lt;casMultiplier&gt; element is optional, and specifies processing
      order of an input CAS relative to its children. If true, a flow of an input CAS will be suspended after it is 
      returned from a Cas Multiplier delegate until all its child CASes have finished processing. If false, an input
      CAS can be processed in parallel with its children.</p>
      
    <p>The &lt;remoteAnalysisEngine&gt; elements are used to specify that the delegate is not co-located, and how
      to connect to it.  The <code class="code">remoteReplyQueueScaleout</code> is optional; if not specified it defaults to 1.
      This scaleout is the number of threads that will be used to do the work of the containing aggregate 
      when replies are returned from this remote delegate.  This work is described above.  
      It may be useful to set this to &gt; 1 if, for instance, 
      there are many CASes coming back from a remote delegate (perhaps the remote is a CAS Multiplier), and each one 
      has to be deserialized.
      </p>
    
    <p>The &lt;serializer&gt; element describes what method of serialization to use. This element is optional and it
    may be set to either <code class="code">binary</code> or <code class="code">xmi</code>. If omitted, <code class="code">xmi</code> serialization 
    will be used by default. <code class="code">Xmi</code> serialization 
    can be quite verbose and produce large output for CASes containing many annotations; on the plus side, 
    it supports serialization between components where the type systems may not be exactly identical (for instance,
    they could be different subsets of larger, common type systems).  <code class="code">Binary</code> serialization produces
    a smaller output size and is more efficient; on the minus side, it requires that the type systems 
    for both components have exactly the same type and feature codes - which in practice means that the 
    type systems have to be identical.   Also, the binary serialization format is new with 2.3.0 release, and is not always
    available.  For example, C++ services do not (currently) support this format. 
    </p>
    <p>
      The &lt;inputQueue&gt; element specifies the remote's input queue. The casMultiplier element inside a remoteAnalysisEngine element is only specified if the
      remote component is a CAS Multiplier, and it specifies the size of a pool of CASes kept to receive the new CASes
      from the remote component, and the initial size of those CASes. Its poolSize must be equal to or larger than the
      casMultiplier poolSize specified for that remote component.</p>

    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As of release 2.3.1, the previous restrictions limiting remote CAS Multiplier to 
    just one have been lifted; you can have any number, and they can be scaled out as well.</p></div>
     
    
    
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The brokerURL value used for this remote delegate must be valid for
    both the client to send requests and the remote service to send replies.</p></div>
    
    <p>Services may be running on nodes with firewalls, where the only port open is the one for http. In this case,
      you can use the http protocol.</p>
    
    <p>The &lt;asyncPrimitiveErrorConfiguration&gt; element is only allowed within a top-level analysis engine
      specification (that is, one that is not a delegate of another, containing analysis engine).</p>
  </div>
  
  
  
  
  <div class="section" title="3.10.&nbsp;Error Configuration descriptors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.errorconfig">3.10.&nbsp;Error Configuration descriptors</h2></div></div></div>
    
    <p>Error Configuration descriptors can be included directly in the deployment descriptors, or they may use
      the &lt;import&gt; mechanism to import another file having the specification. </p>
    <p>For AS Aggregates, the configuration applicable to delegates goes in
      &lt;asyncAggregateErrorConfiguration&gt; elements for the delegate. </p>
    <p>For AS Primitives, there is one &lt;asyncPrimitiveErrorConfiguration&gt; element that configures
      threshold-based termination. The other kinds of error configuration are not applicable for AS Primitives.
      </p>
    <p>See <span class="olink">????</span> for a complete
      overview of error handling. </p>
    
    
    
    <p>The Error Configuration descriptor for AS Aggregates is as follows; note that all the elements are
      optional:
      
      
      </p><pre class="programlisting">&lt;asyncAggregateErrorConfiguration 
      xmlns="http://uima.apache.org/resourceSpecifier"&gt;

  &lt;!-- the standard (optional) header --&gt;
  &lt;name&gt;[String]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;

  &lt;import ... /&gt;  &lt;!-- optional --&gt;   

  &lt;getMetadataErrors
          maxRetries="n" 
          timeout="xxx_milliseconds"
          errorAction="disable|terminate"/&gt; 

  &lt;processCasErrors
          maxRetries="n" 
          timeout="xxx_milliseconds"
          continueOnRetryFailure="true|false"
          thresholdCount="xxx"
          thresholdWindow="yyy"
          thresholdAction="disable|terminate"/&gt;

  &lt;collectionProcessCompleteErrors
          timeout="xxx_milliseconds"
          additionalErrorAction="disable|terminate"/&gt;

&lt;/asyncAggregateErrorConfiguration&gt;</pre>
    
    <p>For an AS Primitive, the &lt;asyncPrimitiveErrorConfiguration&gt; element appears at the top level, and
      has this form:
      
      </p><pre class="programlisting">&lt;asyncPrimitiveErrorConfiguration 
      xmlns="http://uima.apache.org/resourceSpecifier"&gt;

  &lt;!-- the standard (optional) header --&gt;
  &lt;name&gt;[String]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;

  &lt;import ... /&gt;  &lt;!-- optional --&gt;   

  &lt;processCasErrors
          thresholdCount="xxx"
          thresholdWindow="yyy"
          thresholdAction="terminate"/&gt;

  &lt;collectionProcessCompleteErrors
          additionalErrorAction="terminate"/&gt;
          
&lt;/asyncPrimitiveErrorConfiguration&gt;</pre><p>
      </p>
    
    
    
    <p> The maxRetries attribute specifies the maximum number of retries to do. If this is set to 0 (the default), no
      retries are done. </p>
    
    <p>The continueOnRetryFailure attribute, if set to 'true' causes the framework to ask the aggregate's flow
      controller if the processing for the CAS can continue. If this attribute is 'false' or if the flow controller
      indicates it cannot continue, further processing on the CAS is stopped and an error is returned from the
      aggregate. Warning: there are some conditions in the current implementation where this is not yet being done;
      this is a known issue. </p>
    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p> If maxRetries &gt; 0 or the continueOnRetryFailure attribute is 'true', the CAS will be saved
    before sending it to remote delegates, to enable these actions. For co-located delegates, the CAS is
    <span class="emphasis"><em>not</em></span> copied and a process failure may cause it to become corrupt. Even though this may
    be true, the continue option is supported. It is the Flow Controller's responsibility to determine what to do 
    with a CAS that failed during processing.
    </p>
    </div>
    
    <p> The timeout attribute specifies the timeout values used when sending commands to the delegates. The units
      are milliseconds and a value of 0 has the special meaning of no timeout.</p>
    
    <p> The thresholdCount and thresholdWindow attributes specify the threshold at which the thresholdAction
      is taken. If xxx errors occur within a window of size yyy, the framework takes the specified action of either
      disabling this delegate, or terminating the containing AS Aggregate (or if not an AS Aggregate, terminating
      the AS Primitive). A thresholdCount of 0 (the default) has the special meaning of no threshold, i.e. errors
      ignored, and a thresholdWindow of 0 (the default) means no window, i.e. all errors counted. </p>
    
    <p> An action of 'disable' applies to the specified delegate, removing it from the flow so the containing
      aggregate will no longer send it commands. The 'terminate' action applies to the entire service containing
      this component, disconnecting it from its input queue and shutting it down. Note that when disabling, the
      framework asks the flow controller to remove the delegate from the flow, but if the flow controller cannot
      reasonably operate without this component it can convert the action to 'terminate' by throwing an
      AnalysisEngineProcessException.FLOW_CANNOT_CONTINUE_AFTER_REMOVE exception. </p>
    
    <p> Note that the only action for an AS Primitive on getMetadata failure is to terminate, and this is always the
      case, so it is not listed as an configuration option. This is also the default action for an AS Aggregate
      getMetadata failure. </p>
    
  </div>
  
  <div class="section" title="3.11.&nbsp;Error Configuration defaults"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.deploy.descriptor.errorconfig.defaults">3.11.&nbsp;Error Configuration defaults</h2></div></div></div>
    
    <p> If the &lt;errorConfiguration&gt; element is omitted, or if some sub elements of this are omitted, the
      following defaults are used:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The maxRetries parameter is set to 0. </p></li><li class="listitem"><p>Timeout defaults are set to 0, meaning no timeout, except for the getMetadata command for
          remote delegates; here the default is 60000 (1 minute)</p></li><li class="listitem"><p>The continueOnRetryFailure action is set to "false".</p></li><li class="listitem"><p>The thresholdCount value is set to 0, meaning no threshold, errors are ignored.</p>
          </li><li class="listitem"><p>The thresholdWindow value is set to 0, meaning no window, all errors are counted.</p>
          </li><li class="listitem"><p>No disable or terminate action will be done (i.e. errors ignored), except for the
          getMetadata command where the default is to terminate.</p></li></ul></div><p> </p>
  </div>
  
</div>
  <div class="chapter" title="Chapter&nbsp;4.&nbsp;Asynchronous Scaleout Application Interface" id="ugr.ref.async.api"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;Asynchronous Scaleout Application Interface</h2></div></div></div>
  
  
  <div class="section" title="4.1.&nbsp;Asynchronous Client API Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.organization">4.1.&nbsp;Asynchronous Client API Overview</h2></div></div></div>
    
    
    <p>
      The Asynchronous Client API provides Java applications the capability to connect to
      and make requests to UIMA-AS services. ProcessCas and CollectionProcessingComplete
      requests are supported.
    </p>

    <p>It provides four kinds of capabilities:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>sending requests, receiving replies, asynchronously (or synchronously)</p></li><li class="listitem"><p>setting timeouts and limits on the number of simultaneous requests in process (via setting
          the CAS Pool size)</p></li><li class="listitem"><p>using an optionally provided collection reader to obtain items to process</p></li><li class="listitem"><p>deploying services as part of the startup process</p></li></ul></div>
      
    <p>
      An application can use this API to 
      prepare and send each CAS to a service one at a time, or
      alternately can use a UIMA collection reader to prepare the CASes to be delivered.
      </p>
      
      <p>
      The application normally provides a listener class to receive asynchronous replies.
      For individual CAS requests a synchronous sendAndReceive call is available. 
      As an alternative for this synchronous call, instead of using this client API, 
      the standard UIMA Analysis Engine APIs
      can be used with an analysis engine instantiated from a JMS Service Descriptor.
      See <a class="xref" href="#ugr.async.ov.concepts.jms_descriptor" title="1.7.&nbsp;JMS Service Descriptor">Section&nbsp;1.7, &#8220;JMS Service Descriptor&#8221;</a>.
    </p>
    
    <p>
      As a convenience, the Asynchronous Client API can also be used to deploy (i.e., "start") services.
      Java services deployed by the API are instantiated in the same JVM. Logging for all UIMA
      components in the same JVM are merged; class names and thread IDs can be used to distinguish
      log entries from different services. All services in the JVM can be monitored by a single
      JMX console. Native C++ UIMA services can be called from the JVM via the JNI or
      optionally be launched as separate processes on the same machine. In either case logging
      and JMX monitoring for native services are integrated with the other UIMA components in the JVM.
    </p>
    
  </div>
  
        
        
        
  <div class="section" title="4.2.&nbsp;The UimaAsynchronousEngine Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.descriptor">4.2.&nbsp;The UimaAsynchronousEngine Interface</h2></div></div></div>
    
    
    <p>An application developer's starting point for accessing UIMA-AS services is the
      UimaAsynchronousEngine Interface. For each service an application wants to use, it
      must instantiate a client object:

      </p><pre class="programlisting">UimaAsynchronousEngine uimaAsEngine = 
        new BaseUIMAAsynchronousEngine_impl();</pre><p>

      The following is a short introduction to some important methods on this class.
      
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="code">void initialize(Map anApplicationContext)</code>: Initializes an asynchronous client. 
            Using configuration provided in the given Map object, this method creates a connection to 
            the UIMA-AS Service queue, creates a response queue, and retrieves the service metadata. 
            This method blocks until a reply is received from the service or a timeout occurs.
            If a collection reader has been specified, its typesystem is merged with that from the
            service. The combined typesystem is used to create a Cas pool.
            On success the application is notified via the listener's initializationComplete() method,
            which is called prior to the original call unblocking.
            Asynchronous errors are delivered to the listener's entityProcessComplete() method.
            See <a class="xref" href="#ugr.ref.async.context.map" title="4.3.&nbsp;Application Context Map">Section&nbsp;4.3, &#8220;Application Context Map&#8221;</a> for more about the ApplicationContext map.
          </p>
        </li><li class="listitem">
          <p><code class="code">void addStatusCallbackListener(UimaASStatusCallbackListener aListener)</code>:
            Plugs in an application-specific listener. The application receives callbacks
            via methods in this listener class. More than one listener can be added.
          </p>
        </li><li class="listitem">
          <p><code class="code">CAS getCAS()</code>: Requests a new CAS instance from a CAS pool. This method 
          blocks until a free instance of CAS is available in the CAS pool. Applications that
          use synchronous <code class="code">sendAndReceive()</code> and <code class="code">getCAS()</code> need to call 
          <code class="code">CAS.reset()</code> before reusing the CAS, or <code class="code">CAS.release()</code> to return 
          it to the CAS pool. Applications that use asynchronous <code class="code">sendCAS()</code> and 
          <code class="code">getCAS()</code> must not call <code class="code">CAS.release()</code> nor <code class="code">CAS.reset()</code>
          unless <code class="code">sendCAS()</code> throws an exception. If <code class="code">sendCAS()</code> call is successful, 
          the UIMA AS framework code releases each CAS automatically when a reply is received. The framework 
          releases a CAS right after a callback listener <code class="code">entityProcessComplete()</code> completes.
          </p>
        </li><li class="listitem">
          <p><code class="code">void sendCAS(CAS aCAS)</code>: Sends a given CAS for analysis to the UIMA-AS Service. 
            The application is notified of responses or timeouts via <code class="code">entityProcessComplete()</code> method.
         </p>
        </li><li class="listitem">
          <p><code class="code">void setCollectionReader(CollectionReader aCollectionReader)</code>: 
            Plugs in an instantiated CollectionReader instance to use. This method must be called before
            <code class="code">initialize</code>.
          </p>
        </li><li class="listitem">
          <p><code class="code">void process()</code>: 
           Starts processing a collection using a collection reader. The method will block
           until the CollectionReader finishes processing the entire collection.  
           Throws ResourceProcessException if a CollectionReader has not been provided or initialize
           has not been called.
          </p>
        </li><li class="listitem">
          <p><code class="code">void collectionProcessingComplete()</code>: Sends a Collection Processing Complete request 
            to the UIMA-AS Analysis Service. This call is cascaded down to all delegates; however, if a particular
            delegate is scaled-out, only one of the instances of the delegate will get this call.  
            The method blocks until all of the components that received this call have returned, or a timeout occurs.
            On success or failure, the application is 
            notified via the statusCallbackListener's collectionProcessComplete() method.
          </p>
        </li><li class="listitem">
          <p><code class="code">void sendAndReceiveCAS(CAS aCAS)</code>:
            Send a CAS, wait for response. On success aCAS contains the analysis results.
            Throws an exception on error.  Note that this interface cannot be used 
            to interface to a CAS Multiplier service, because it will block until the
            parent comes back, and any child CASes will be ignored.
          </p>
        </li><li class="listitem">
          <p><code class="code">void sendAndReceiveCAS(CAS aCAS, List&lt;AnalysisEnginePerformanceMetrics&gt; componentMetricsList)</code>:
            Send a CAS, wait for response. On success aCAS contains the analysis results and componentMetricsList
            contains per Analysis Engine performance breakdown. This breakdown shows how much time each Analysis Engine
            took to analyze the CAS. The method throws an exception on error.  Note that this interface cannot be used 
            to interface to a CAS Multiplier service, because it will block until the parent comes back, and any child 
            CASes will be ignored.
          </p>
        </li><li class="listitem">
          <p><code class="code">String aHandle deploy( String aDeploymentDescriptor, Map anApplicationContext)</code>: 
            Deploys the UIMA-AS
            service specified by the given deployment descriptor in this JVM, and returns a handle 
            for this service. The application context map must contain DD2SpringXsltFilePath and
            SaxonClasspath entries. This call blocks until the service is ready to process requests, or an
            exception occurs during deployment.  If an exception occurs, the callback listener's </p>
        </li><li class="listitem">
          <p><code class="code">void undeploy(String aHandle)</code>:
            Tells the specified service to terminate.  The handle is the same handle that is returned
            by the corresponding <code class="code">deploy(...)</code> method.
          </p>
        </li><li class="listitem">
          <p><code class="code">void stop()</code>:
           Stops the asynchronous client. Removes the Cas pool, drops the connection to the UIMA-AS
           service queue and stops listening on its response queue. 
           Terminates and undeploys any services which have been started with this client.
          </p>
          <p>This is an asynchronous call, and can be called at any time.</p>
        </li><li class="listitem">
          <p><code class="code">void stopProducingCases()</code>: Send stop signals for all CASes that are
            currently in process (where the API is expecting responses). If a CAS is a parent
            of child CASes being produced by a CAS Multiplier, this operation will also
            signal the CAS Multiplier to stop producing new CASes.</p>
        </li><li class="listitem">
          <p><code class="code">void stopProducingCases(String aCasReferenceId)</code>: send a stop
            request to a UIMA-AS Service for a particular CAS-id.  If that CAS is a parent
            of child CASes being produced by a CAS Multiplier, this operation will also
            signal the CAS Multiplier to stop producing new CASes.</p>
        </li></ul></div>

    </div>


        
        
        
    <div class="section" title="4.3.&nbsp;Application Context Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.context.map">4.3.&nbsp;Application Context Map</h2></div></div></div>
      
      <p>The application context map is used to pass initialization parameters. These parameters are itemized
        below.
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>DD2SpringXsltFilePath: Required for deploying services.</p>
          </li><li class="listitem">
            <p>SaxonClasspath: Required for deploying services.</p>
          </li><li class="listitem">
            <p>ServerUri: Broker connector for service. Required for initialize.</p>
          </li><li class="listitem">
            <p>Endpoint: Service queue name. Required for initialize.</p>
          </li><li class="listitem">
            <p>Resource Manager: (Optional) a UIMA ResourceManager to use for the client.</p>
          </li><li class="listitem">
            <p>CasPoolSize: Size of Cas pool to create to send to specified service. Default = 1.</p>
          </li><li class="listitem">
            <p>CAS_INITIAL_HEAPSIZE: (Optional) the initial CAS heapsize, in 4-byte words.  Default = 500,000.</p>
          </li><li class="listitem">
            <p>Application Name: optional name of the application using this API, for logging.</p>
          </li><li class="listitem">
            <p>Timeout: Process CAS timeout in ms. Default = no timeout.</p>
          </li><li class="listitem">
            <p>GetMetaTimeout: Initialize timeout in ms. Default = 60 seconds.</p>
          </li><li class="listitem">
            <p>CpcTimeout: Collection process complete timeout. Default = no timeout.</p>
          </li><li class="listitem">
            <p>SerializationStrategy:(Optional) xmi or binary serialization. Default = xmi </p>
          </li><li class="listitem">
            <p>userName:(Optional) to authenticate user with ActiveMQ broker. Default = null </p>
          </li><li class="listitem">
            <p>password:(Optional) to authenticate user with ActiveMQ broker. Default = null </p>
          </li></ul></div>
      
    </div>


        
        
        
    <div class="section" title="4.4.&nbsp;Status Callback Listener"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.callback.listener">4.4.&nbsp;Status Callback Listener</h2></div></div></div>
      
      <p>Asynchronous events are returned to applications via methods in classes registered
          to the Client API object with addStatusCallbackListener(). These classes must extend the
          class org.apache.uima.aae.client.UimaAsBaseCallbackListener.
          

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="code">initializationComplete(EntityProcessStatus aStatus)</code>: The callback used to inform the
            application that the initialization request has completed. On success aStatus will be
            null; on failure use the UimaASProcessStatus class to get the details.</p>
        </li><li class="listitem">
          <p><code class="code">entityProcessComplete(CAS aCas, EntityProcessStatus aStatus)</code>: The callback used to 
            inform the application that a processCas request has completed. On success aCAS object
            will contain result of analysis; on failure the CAS will be in the same state as 
            before it was sent to a service and aStatus will contain the cause of failure. When calling 
            this method, UIMA AS passes an object of type <code class="code">UimaASProcessStatus</code> as a second argument. 
            This class extends <code class="code">EntityProcessStatus</code> and provides 4 additional methods: <code class="code">getCAS(), 
            getCasReferenceId(), getParentCasReferenceId() &amp; getPerfomanceMetricsList().</code> 
			The last method provides the per component performance breakdown as reported by the UIMA
            Analysis Engine which includes the elapsed time each component spent analyzing the CAS. 
            The <code class="code">AnalysisEnginePerformanceMetrics</code> class provides the following API:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <p><code class="code">public String getName()</code>: identifies component by name</p>
              </li><li class="listitem">
                <p><code class="code">public String getUniqueName()</code>: identifies component by unique name</p>
              </li><li class="listitem">
                <p><code class="code">public long getAnalysisTime()</code>: time (in millis) component spent analyzing the CAS</p>
              </li><li class="listitem">
                <p><code class="code">public long getNumProcessed()</code>: total number of CASes processed so far by the component</p>
              </li></ul></div><p>
            See <a class="xref" href="#ugr.ref.async.api.usage_getresults" title="4.6.3.&nbsp;Retrieving Asynchronous Results">Section&nbsp;4.6.3, &#8220;Retrieving Asynchronous Results&#8221;</a> for a usage example.
          </p>
        </li><li class="listitem">
          <p><code class="code">collectionProcessComplete(EntityProcessStatus aStatus)</code>: The callback used to inform the
            application that the CPC request has completed. On success aStatus will be
            null; on failure use the <code class="code">UimaASProcessStatus</code> class to get the details.</p>
        </li><li class="listitem">
          <p><code class="code">onBeforeMessageSend(UimaASProcessStatus status)</code>: The callback used to inform the
            application that a CAS is about to be sent to a service. The status object has
            <code class="code">getCasReferenceId()</code> method that returns a unique CAS id assigned by UIMA AS.
            This reference id may be used to associate arbirary information with a CAS, and is also
            returned in the callback listener as part of the status object.</p>
        </li><li class="listitem">
          <p><code class="code">onBeforeProcessCAS(UimaASProcessStatus status, String nodeIP, String pid)</code>: The callback 
            used to inform the application that a CAS has been delivered to UIMA AS service and is about to be processed. 
            The status object has <code class="code">getCasReferenceId()</code> method that returns a unique CAS id assigned by 
            UIMA AS. The nodeIP contains IP address of a machine where UIMA AS service is running. The pid contains
            UIMA AS service PID and a thread id. Its syntax is:&lt;PID&gt;:&lt;thread id&gt;. The thread id identifies which 
            thread in UIMA AS service analyzes a CAS.
		  </p>
        </li></ul></div><p>
      </p>
  </div>


        
        
        
    <div class="section" title="4.5.&nbsp;Error Results"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.error.status">4.5.&nbsp;Error Results</h2></div></div></div>
      
      <p>Errors are delivered to the callback listeners as an 
        <code class="code">EntityProcessStatus</code> or <code class="code">UimaASProcessStatus</code> object.
        These objects provide the methods:          
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="code">isException()</code>: Indicates the error returned is in the form of exception messages.
            </p>
        </li><li class="listitem">
          <p><code class="code">getExceptions()</code>: Returns a List of exceptions.
            </p>
        </li></ul></div><p>
      </p>
  </div>
  
  <div class="section" title="4.6.&nbsp;Asynchronous Client API Usage Scenarios"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.usage">4.6.&nbsp;Asynchronous Client API Usage Scenarios</h2></div></div></div>
    

  <div class="section" title="4.6.1.&nbsp;Instantiating a Client API Object"><div class="titlepage"><div><div><h3 class="title" id="ugr.ref.async.api.usage_initialize">4.6.1.&nbsp;Instantiating a Client API Object</h3></div></div></div>
    
    <p>
      A client API object must be instantiated for each remote service an application will 
      directly connect with, and a listener class registered in order to process asynchronous events:
        </p><pre class="programlisting">//create Asynchronous Client API
uimaAsEngine = new BaseUIMAAsynchronousEngine_impl();
uimaAsEngine.addStatusCallbackListener(new MyStatusCallbackListener());
    </pre><p>
    </p>
  </div>

  <div class="section" title="4.6.2.&nbsp;Calling an Existing Service"><div class="titlepage"><div><div><h3 class="title" id="ugr.ref.async.api.usage_callservice">4.6.2.&nbsp;Calling an Existing Service</h3></div></div></div>
    
    <p>
      The following code shows how to establish connection to an existing service:
        </p><pre class="programlisting">//create Map to pass server URI and Endpoint parameters
Map&lt;String,Object&gt; appCtx = new HashMap&lt;String,Object&gt;();
// Add Broker URI on local machine
appCtx.put(UimaAsynchronousEngine.ServerUri, "tcp://localhost:61616");
// Add Queue Name
appCtx.put(UimaAsynchronousEngine.Endpoint, "RoomNumberAnnotatorQueue");
// Add the Cas Pool Size
appCtx.put(UimaAsynchronousEngine.CasPoolSize, 2);

//initialize
uimaAsEngine.initialize(appCtx);
    </pre><p>
    </p>

    <p>
      Prepare a Cas and send it to the service:
    </p><pre class="programlisting">//get an empty CAS from the Cas pool
CAS cas = uimaAsEngine.getCAS();
// Initialize it with input data
cas.setDocumentText("Some text to pass to this service.");
// Send Cas to service for processing
uimaAsEngine.sendCAS(cas);
    </pre><p>
    </p>
  </div>

  <div class="section" title="4.6.3.&nbsp;Retrieving Asynchronous Results"><div class="titlepage"><div><div><h3 class="title" id="ugr.ref.async.api.usage_getresults">4.6.3.&nbsp;Retrieving Asynchronous Results</h3></div></div></div>
    
    <p>
      Asynchronous events resulting from the process Cas request are passed to the registered listener.
        </p><pre class="programlisting">
// Callback Listener. Receives event notifications from UIMA-AS.
class MyStatusCallbackListener extends UimaAsBaseCallbackListener {

  // Method called when the processing of a Document is completed.
  public void entityProcessComplete(CAS aCas, EntityProcessStatus aStatus) {
    if (aStatus != null &amp;&amp; aStatus.isException()) {
      List exceptions = aStatus.getExceptions();
      for (int i = 0; i &lt; exceptions.size(); i++) {
        ((Throwable) exceptions.get(i)).printStackTrace();
      }
      uimaAsEngine.stop();
      return;
    }

    // Process the retrieved Cas here
    if ( aStatus instanceof UimaASProcessStatus ) {
      String casReferenceId = 
        ((UimaASProcessStatus)aStatus).getCasReferenceId();
      List&lt;AnalysisEnginePerformanceMetrics&gt; metrics = 
        ((UimaASProcessStatus)aStatus).getPerformanceMetricsList();
    }
    // ...
  }

  // Add other required callback methods below...
}
    </pre><p>
    </p>
  </div>

  <div class="section" title="4.6.4.&nbsp;Deploying a Service with the Client API"><div class="titlepage"><div><div><h3 class="title" id="ugr.ref.async.api.usage_deployservice">4.6.4.&nbsp;Deploying a Service with the Client API</h3></div></div></div>
    
    <p>
      Services can be deployed from a client object independently of any service connection.
      The main motivation for this feature is to be able to deploy a service, connect to it, and
      then remove the service when the application is done using it.
        </p><pre class="programlisting">// create Map to hold required parameters
Map&lt;String,Object&gt; appCtx = new HashMap&lt;String,Object&gt;();
appCtx.put(UimaAsynchronousEngine.DD2SpringXsltFilePath, 
           System.getenv("UIMA_HOME") + "/bin/dd2spring.xsl");
appCtx.put(UimaAsynchronousEngine.SaxonClasspath, 
           "file:" + System.getenv("UIMA_HOME") + "/saxon/saxon8.jar");
uimaAsEngine.deploy(service, appCtx);
    </pre><p>
    </p>
  </div>
      
    </div>

  <div class="section" title="4.7.&nbsp;Undeploying a Service with the Client API"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.usage_undeployservice">4.7.&nbsp;Undeploying a Service with the Client API</h2></div></div></div>
    
    <p>
      Services can be undeployed from a client object as follows: 
        </p><pre class="programlisting">// create Map to hold required parameters
Map&lt;String,Object&gt; appCtx = new HashMap&lt;String,Object&gt;();
appCtx.put(UimaAsynchronousEngine.DD2SpringXsltFilePath, 
           System.getenv("UIMA_HOME") + "/bin/dd2spring.xsl");
appCtx.put(UimaAsynchronousEngine.SaxonClasspath, 
           "file:" + System.getenv("UIMA_HOME") + "/saxon/saxon8.jar");
String id = uimaAsEngine.deploy(service, appCtx);
uimaAsEngine.undeploy(id);
    </pre><p>
    </p>
  </div>
      
  <div class="section" title="4.8.&nbsp;Recovering from broker failure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.recovery">4.8.&nbsp;Recovering from broker failure</h2></div></div></div>
    
    <p>
      The Client API has a built in recovery strategy to handle cases where a
      broker fails or becomes unreachable, and then, later becomes available
      again.  
    </p>  
    <p>
      Before sending a new request to a broker, the client checks the state of 
      its connection. If the connection has failed, 
      the client enters a loop where it will attemp to reconnect 
      every 5 seconds.  One message is logged to notify this 
      is happening.  The recovery attempt stops when
      the the connection is recovered, or when all UIMA AS clients 
      that are sharing this failed connection, terminate.
      </p>
      <p>
      During the recovery attempt, any CASes that are submitted via the
      client APIs will fail or timeout.  
      If the application uses the sendAndReceive() synchronous API, 
      the failure will be delivered by an exception. 
      If the application client uses the sendCAS() asynchronous API, 
      the failure will be delivered via the normal callback listener that 
      the application registered with the UIMA AS client.
    </p>    
  </div>  
  <div class="section" title="4.9.&nbsp;Generating Deployment Descriptor Programmatically"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ref.async.api.descriptor.generation">4.9.&nbsp;Generating Deployment Descriptor Programmatically</h2></div></div></div>
    
    <p>The uima-as includes a Deployment Descriptor Factory to facilitate programmatic creation 
    of both Primitive and Aggregate Deployment Descriptors. The factory and its supporting classes 
    provide an API to manipulate all aspects of the Deployment Descriptor, including scaleout, 
    error handling, etc. The following is a snippet of java code showing how to generate a Primitive
    Deployment Descriptor, override default scaleout and error handling settings, and deploy a 
    service.
    
  
  </p><pre class="programlisting">
// Set up a context object containing basic service deployment information
ServiceContext context = 
	new ServiceContextImpl("PersonTitle", 
				           "PersonTitle Annotator Description",
				           "c://PersonTitleAnnotator.xml", 
				           "PersonTitleQueue", "tcp://localhost:61616");
            
// create DD with default settings
UimaASPrimitiveDeploymentDescriptor dd =
	DeploymentDescriptorFactory.
		createPrimitiveDeploymentDescriptor(context);

// Get default Error Handler for Process        
dd.getProcessErrorHandlingSettings().setThresholdCount(4);
			
// Two instances of AE in a jvm
dd.setScaleup(2);
			
//	Generate deployment descriptor in xml format
String ddXML = dd.toXML(); 
// Write the DD to a temp file
File tempFile = 
	File.createTempFile("Deploy_PersonTitle", ".xml");
BufferedWriter out = 
	new BufferedWriter(new FileWriter(tempFile));
out.write(ddXML);
out.close();			
            
// create a Map to hold required parameters
Map&lt;String,Object&gt; appCtx = 
	new HashMap&lt;String,Object&gt;();
appCtx.put(UimaAsynchronousEngine.DD2SpringXsltFilePath, 
	System.getenv("UIMA_HOME") + "/bin/dd2spring.xsl");
appCtx.put(UimaAsynchronousEngine.SaxonClasspath, 
	"file:" + System.getenv("UIMA_HOME") + "/saxon/saxon8.jar");
            
// Deploy service 
uimaAsEngine.deploy(tempFile.getAbsolutePath(), appCtx);			
			
       </pre><p>
       </p>
       </div> 
        
        
        

    <div class="section" title="4.10.&nbsp;Sample Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.ref.async.api.sample.code">4.10.&nbsp;Sample Code</h2></div></div></div>
      
      <p>See $UIMA_HOME/examples/src/org/apache/uima/examples/as/RunRemoteAsyncAE.java
      </p>
    </div>



</div>
  <div class="chapter" title="Chapter&nbsp;5.&nbsp;Monitoring, Tuning and Debugging" id="ugr.async.mt"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;5.&nbsp;Monitoring, Tuning and Debugging</h2></div></div></div>
  
  <p>
    UIMA AS deployments can involve many separate parts running on many
    different machines.  Monitoring facilities and tools built into UIMA AS help
    in collecting information on the performance of these parts.  You can
    use the monitoring information to identify deployment issues, such as
    bottlenecks, and address these with various approaches that alter the
    deployment choices; this is what we mean by "tuning the deployment".
  </p>
  
  <p>
    Monitoring happens in several parts:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Each node running a JVM hosting UIMA AS services or clients provides
        JMX information tracking many items of interest.</p></li><li class="listitem">
        <p>UIMA AS services include some of these measurements in the information
          passed back to its client, along with the returned CAS.  This allows
          clients to collect and aggregate measurements over a cluster of remotely-deployed
          components.</p>
      </li></ul></div><p>
  </p>
  
  <p>Tuning a UIMA AS application is done using several approaches:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>changing the topology of the scaleout - for instance, allocating more
        nodes to some parts, less to others</p></li><li class="listitem">
        <p>adjusting deployment parameters, such as the number of CASes in a CasPool, or
          the number of threads assigned to do various tasks</p>
      </li></ul></div><p>
  </p>
  
  <p>
    In addition, tuning can involve changing the actual analytic algorithms
    to tune them - but that is beyond the scope of this chapter.
  </p>

  <p>
	UIMA AS scale out configurations add multithreaded and out-of-order execution complexities to 
	core UIMA applications. Debugging a UIMA AS application is aided by UIMA's modular architecture 
	and an approach that exercises the code gradually from simpler to more complex configurations.
	Two useful built-in debug features are:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p>Java errors at any component level are propagated back to the component originating 
      	the request, with a full call chain of UIMA AS components, within
		colocated aggregate components and across remote services which are 
		shared by multiple clients.</p>
      </li><li class="listitem">
        <p>CASes can be saved before sending to any local or remote 
        	delegate and later used to reproduce problems in a simple unit testing environment.</p>
      </li></ul></div><p>
  </p>
    
  
  <div class="section" title="5.1.&nbsp;Monitoring"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.mt.monitoring">5.1.&nbsp;Monitoring</h2></div></div></div>
    
      
    <div class="section" title="5.1.1.&nbsp;JMX"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.jmx">5.1.1.&nbsp;JMX</h3></div></div></div>
      
      <p>JMX (Java Management Extensions) is a standard Java mechanism that
        is used to monitor and control Java applications.  A standard Java tool
        provided with most Javas, called
        <code class="code">jconsole</code>, is a GUI based application that can connect to
        a JVM and display the information JMX is providing, and also control
        the application in application-defined specific ways.</p>
        
      <p>JMX information is provided by a hierarchy of JMX Beans.  More
        background and information on JMX and the jconsole tool is available on the web.</p>
        
      
    </div>
    <div class="section" title="5.1.2.&nbsp;JMX Information from UIMA AS"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.jmx_monitoring">5.1.2.&nbsp;JMX Information from UIMA AS</h3></div></div></div>
      
      
      <p>JMX information is provided by every UIMA AS service or client as it runs.
        Each item provided is either an instantaneous measurement (
        e.g. the number of items in a queue) or an accumulating measurement (
        e.g. the number of CASes processed).  Accumulating measures
        can be reset to 0 using standard JMX mechanisms.</p>
        
      <p>
        JMX information is provided on a JVM basis; a JVM can be hosting 0 or more
        UIMA AS Services and/or clients.  A UIMA AS Service is defined as a component
        that connects to a queue
        and accepts CASes to process.  A UIMA AS Client, in contrast, sends CASes to
        be processed; it can be a top level client, or
        a UIMA AS Service having one or more AS Aggregate delegates, to which it is
        sending CASes to be processed.
      </p>
      
      <p>
        UIMA AS Services send
        some of their measurements back to the UIMA AS Clients that sent them CASes; those
        clients incorporate these measurements into aggregate statistics that they provide.
        This allows accumulating information among components deployed over many nodes 
        interconnected on a network.
      </p>
     
      <p>
        Some JMX measurement items are constant, and document various settings, descriptors, 
        names, etc., in use by the (one or more) UIMA AS services and/or 
        clients running on this JVM.</p>

      <p>Some time measurements are associated with running some process.  These,
        where possible, are cpu times, as measured by the thread or threads running the process, using the
        ThreadMXBean class.  On some Javas, thread-based cpu time may not be supported, however.  In that
        case, wall-clock time is used instead.</p>
        
      <p>  
        If the process is multi-threaded, and the cpu has multiple cores, 
        you can get time measurements which exceed the wall clock interval, due to the process consuming
        cpu time on multiple threads at once.</p>
        
      <p>Timing information not associated with running code, such as idle time, is measured as wall-clock time.</p>      
            
      <p>The following sections describe the JMX Beans implemented by UIMA AS.  The
        Notes in the tables include the following flags:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><span class="bold"><strong>inst/acc/const</strong></span> - instantaneous, accumulating, or constant measurement</p>
          </li><li class="listitem">
            <p><span class="bold"><strong>sent</strong></span> - sent up to the invoking client with returning CAS</p>
          </li></ul></div><p>
      </p>
      
      <div class="section" title="5.1.2.1.&nbsp;UIMA AS Services JMX measures"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.mt.jmx_monitoring.service">5.1.2.1.&nbsp;UIMA AS Services JMX measures</h4></div></div></div>
        
        <p>The next 4 tables detail the JMX measures provided by UIMA AS services.</p>
        <div class="section" title="Service information"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.constant.service">Service information</h5></div></div></div>
          
          <div class="informaltable">
            <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">state</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The state of the service (Running, Initializing, Disabled, Stopping, Failed)</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">input queueName</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The name of the input queue</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">reply queueName</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The internally generated name of the reply queue</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const (but could change due to reconnection recovery)</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">broker URL</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The URL of the JMS queue broker</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">deployment descriptor</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The path to the deployment descriptor for this service</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is CAS Multiplier</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is this Service a CAS Multiplier</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">boolean</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is top level</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is this Service a top level service, meaning that it connects to
                    an input queue on a queue broker</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">boolean</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">service key</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The key name used in the associated Analysis Engine aggregate that specifies
                    this as a delegate</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is Aggregate</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">is this service an AS Aggregate (i.e., has delegates and
                    is marked async="true")</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">boolean</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; ">analysisEngine instance count</td><td style="border-right: 0.5pt solid black; ">The number of replications of the AS Primitive</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">const</td></tr></tbody></table>
          </div>                  
        </div>
        
        
      <div class="section" title="Service Performance Measurements"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.service.performance">Service Performance Measurements</h5></div></div></div>
        
        <div class="informaltable">
          <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of CASes processed</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of CASes processed by a component</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count - CASes</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">cas deserialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The thread time spent deserializing CASes (receiving, either from client, or replies from delegates)</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">cas serialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The thread time spent serializing CASes (sending, either to delegates or back to client)</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count - CASes</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">analysis time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The thread time spent in AS Primitive analytics</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">idle time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The wall clock time a service has been idle.  Measure starts
                  after a reply is sent until the next request is receives, and excludes
                  serialization/deserialization times.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">cas pool wait time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The time spent waiting for a CAS to become available in the CAS Pool</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">shadow cas pool wait time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">A shadow cas pool is established for services which are Cas Multipliers.  
                  This is the time spent waiting for a CAS to become available in the Shadow CAS Pool.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">time spent in CM getNext</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The time spent inside Cas Multipliers, getting another CAS.  
                  This time (doesn't include / includes ????)
                  the time 
                  spent waiting for a CAS to become available in the CAS Pool waiting for a CAS to become available in the CAS Pool</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">process thread count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of threads available to process requests (number
                  of instances of a primitive)</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; ">reply thread count</td><td style="border-right: 0.5pt solid black; ">The number of threads available to process replies</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">const</td></tr></tbody></table>
        </div>        
      </div>

      <div class="section" title="Co-located Service Queues"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.service.internal.queues">Co-located Service Queues</h5></div></div></div>
        
        <p>Co-located services use light-weight, internal (not JMS) queues.  
          These have similar measures as are used with JMS queues, and include
          these measures for both the input queues and the reply (output) queues:
          </p><div class="informaltable">
            <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">consumer count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of threads configured to read the queue</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">dequeue count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of CASes that have been read from this queue</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; ">queue size</td><td style="border-right: 0.5pt solid black; ">The number of CASes in the queue</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">inst</td></tr></tbody></table>
          </div><p>   
        </p>
      </div>
      
      <div class="section" title="Service Error Measurements"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.service.error">Service Error Measurements</h5></div></div></div>
        
        <div class="informaltable">
          <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">process Errors</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of process errors</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">getMetadata Errors</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The number of getMetadata errors</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; ">cpc Errors</td><td style="border-right: 0.5pt solid black; ">The number of Collection Process Complete (cpc) errors</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">acc</td></tr></tbody></table>
        </div>   
      </div>
      
    </div>

        <div class="section" title="5.1.2.2.&nbsp;Application Client information"><div class="titlepage"><div><div><h4 class="title" id="ugr.async.mt.jmx_monitoring.client">5.1.2.2.&nbsp;Application Client information</h4></div></div></div>
          
          <p>This section describes monitoring
            information provided by the UIMA AS Client APIs. 
            Any code that uses the <a class="xref" href="#ugr.ref.async.api.organization" title="4.1.&nbsp;Asynchronous Client API Overview">Section&nbsp;4.1, &#8220;Async Client API&#8221;</a>, 
            such as the example application
            client <code class="code">RunRemoteAsyncAE</code>, will have a set of these
            JMX measures.  Currently no additional
            tooling (beyond standard tools like <code class="code">jconsole</code>) are provided to
            view these.
          </p>
          
          <div class="section" title="Client Measures"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.client.measures">Client Measures</h5></div></div></div>
            
          <div class="informaltable">
            <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">application Name</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">A user-supplied string identifying the application</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">service queue name</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The name of the service queue this client connects to</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">serialization method</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">either xmi or binary. This is the serialization the client will use to send
                    CASes to the service, and also tells the service which serialization to use
                    in sending the CASes back.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">string</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">cas pool size</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">This client's cas pool size, limiting the number of simultaneous outstanding requests in process</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">const</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total number of CASes processed</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count of the total number of CASes sent from this client.  Note: in the case
                  where the service is a Cas Multiplier, the "child" CASes are not included in this count.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total time to process</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total thread time spent in processing all CASes, including time in remote delegates</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average process time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total number of CASes processed / total time to process</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max process time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum thread time spent in processing a CAS, including time in remote delegates</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total serialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total thread time spent in serializing, both to delegates 
                  (and recursively, to their delegates) and replies back to senders</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average serialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average thread time spent in serializing a CAS, both to delegates 
                  (and recursively, to their delegates) and replies back to senders</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max serialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum thread time spent in serializing a CAS, both to delegates
                  (and recursively, to their delegates) and replies back to senders</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total deserialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total thread time spent in deserializing, both replies from delegates and CASes from upper
                  level components being sent to lower level ones.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average deserialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average thread time spent in deserializing, both replies from delegates and CASes from upper
                  level components being sent to lower level ones.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max deserialization time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum thread time spent in deserializing, both replies from delegates and CASes from upper
                  level components being sent to lower level ones.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total idle time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total wall clock time a top-level service thread has been idle since the thread was last used.
                  If there is more than one service thread, this number is the sum.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average idle time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average wall clock time all top-level service threads have been idle since they were last used</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max idle time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum wall clock time a top-level service thread has been idle since the thread was last used</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total time waiting for reply</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total wall clock time, measured from the time a CAS is sent to the top-level queue, until that CAS
                  is returned.  Any generated CASes from Cas Multipliers are not counted in this measurement.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average time waiting for reply</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average wall clock time from the time a CAS is sent to the reply is received</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max time waiting for reply</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum wall clock time from the time a CAS is sent to the reply is received</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total response latency time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total wall clock time, measured from the time a CAS is sent to the top-level queue, including
                  the serialization and deserialization times at the client, until that CAS
                  is returned.  Any generated CASes from Cas Multipliers are not counted in this measurement.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average response latency time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average wall clock time, measured from the time a CAS is sent to the top-level queue, including
                  the serialization and deserialization times at the client, until that CAS
                  is returned.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max response latency time</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum wall clock time, measured from the time a CAS is sent to the top-level queue, including
                  the serialization and deserialization times at the client, until that CAS
                  is returned.</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total time waiting for CAS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">total wall-clock time spent waiting for a 
                  free CAS to be available in the client's CAS pool, before
                  sending the CAS to input queue for the top level service. </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average time waiting for CAS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">average wall-clock time spent waiting for a 
                  free CAS to be available in the client's CAS pool</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">max time waiting for CAS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">maximum wall-clock time spent waiting for a 
                  free CAS to be available in the client's CAS pool</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">milli seconds</td><td style="border-bottom: 0.5pt solid black; ">inst</td></tr><tr><td style="border-right: 0.5pt solid black; ">total number of CASes requested</td><td style="border-right: 0.5pt solid black; ">total number of CASes fetched from the CAS pool</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">acc</td></tr></tbody></table>
        </div>         
      </div>
      
      <div class="section" title="Client Error Measurements"><div class="titlepage"><div><div><h5 class="title" id="ugr.async.mt.jmx_monitoring.client.error">Client Error Measurements</h5></div></div></div>
        
        <div class="informaltable">
          <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Units</th><th style="border-bottom: 0.5pt solid black; " align="center">Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">getMeta Timeout Error Count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of times a getMeta timed out</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">getMeta Error Count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of times a getMeta request returned with an error</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">process Timeout Error Count</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of times a process call timed out</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">count</td><td style="border-bottom: 0.5pt solid black; ">acc</td></tr><tr><td style="border-right: 0.5pt solid black; ">process Error Count</td><td style="border-right: 0.5pt solid black; ">number of times a process call returned with an error</td><td style="border-right: 0.5pt solid black; ">count</td><td style="">acc</td></tr></tbody></table>
        </div>
      </div>      
    </div>  
    </div> 
    </div> 
    
    <div class="section" title="5.2.&nbsp;Logging Sampled JMX information at intervals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.mt.jmx_sampling">5.2.&nbsp;Logging Sampled JMX information at intervals</h2></div></div></div>
      
      
      <p>
        A common tuning procedure is to run a deployment for a fairly long time with a
        typical load, and to see what and where hot spots develop.  During this process, 
        it is sometimes useful to convert accumulating measurements into averages, perhaps
        averages per CAS processed.
      </p>
      <p>
        UIMA AS includes a monitor component, org.apache.uima.aae.jmx.monitor.JmxMonitor, 
        to sample JMX measures at specified intervals,
        compute various averages, and write the results into the UIMA Log (or on the console 
        if no log is configured).  The monitor program can be automatically enabled for any deployed service
        by specifying <code class="code">-D</code> parameters on the JVM command 
        line which launches the service, or, it can be run stand-alone; when run stand-alone, you provide an
        argument specifying the JVM it is to connect to to get the JMX information.  It only connects
        to one JVM per run; typically, you would connect it to the top-level service.  
      </p>
      
      <p>
        The monitor outputs information for that service and its immediate delegates (local or remote); however, it
        includes information from the complete recursive chain of delegates when computing its measures.  You can
        get detailed monitoring for sub-services by starting or attaching a monitor to those sub-services.
      </p>
      
      <p>
        ActiveMQ uses Queue Brokers to manage the JMS queues used by UIMA AS.  These brokers have JMX information
        that is useful in tuning applications.  The Monitor program identifies the Queue Broker being used by the 
        service, and connects to it and incorporates information about queue lengths (both the input queue 
        and the reply queue) into its measurements.
      </p>
      
      <div class="section" title="5.2.1.&nbsp;Configuring JVM to run the monitor"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.jmx_sampling.configuring">5.2.1.&nbsp;Configuring JVM to run the monitor</h3></div></div></div>
        
        <p>Specify the following JVM System Variable parameters to configure a UIMA AS Client or Service to enable 
          sampling and logging of JMX measures:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-Duima.jmx.monitor.interval=1000</code> - (default is 1000) specifies the 
              sampling interval in milliseconds</p></li><li class="listitem"><p><code class="code">-Duima.jmx.monitor.formatter=&lt;CustomFormatterClassName&gt;</code></p></li><li class="listitem"><p><code class="code">-Dcom.sun.management.jmxremote</code> - enable JMX (only needed for local monitoring, not needed if port is specified)</p></li><li class="listitem"><p><code class="code">-Dcom.sun.management.jmxremote.port=8009</code></p></li><li class="listitem"><p><code class="code">-Dcom.sun.management.jmxremote.authenticate=false</code></p></li><li class="listitem"><p><code class="code">-Dcom.sun.management.jmxremote.ssl=false</code></p></li></ul></div><p>
          
          This configures JMX to run on port 8009 with no authentication, and sets the sampling interval to 1 second,
          and specifies a custom formatter class name.
        </p>
        
        <p>There are two <code class="code">formatter-classes</code> provided with UIMA AS:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">org.apache.uima.aae.jmx.monitor.BasicUimaJmxMonitorListener - </code>
              this is a multi-line formatter that formats for human-readable output</p></li><li class="listitem"><p><code class="code">org.apache.uima.aae.jmx.monitor.SingleLineUimaJmxMonitorListener - </code>
              this is a formatter that produces one line per interval, suitable for importing into 
              a spreadsheet program.</p></li></ul></div><p>
          
          Both of these log to the UIMA log at the INFO log level.
        </p>
        
        <p>You can also write your own formatter.  The monitor provides an API to plug in a custom formatter 
          for displaying service metrics. A custom formatter must implement JmxMonitorListener interface. 
          See the method <code class="code">startMonitor</code> in the class <code class="code">UIMA_Service</code> for an
          example of how custom JMX Listeners are plugged into the monitor. 
        </p> 
      </div> 
      
      <div class="section" title="5.2.2.&nbsp;Running the Monitor program standalone"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.jmx_sampling.standalone">5.2.2.&nbsp;Running the Monitor program standalone</h3></div></div></div>
        
        <p>The monitor program can be started separately and pointed to a running UIMA AS Client or Service.
          To start the program, invoke Java with the following classpath and parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p>ClassPath:</p>
              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>%UIMA_HOME%/lib/uimaj-as-activemq.jar</p></li><li class="listitem"><p>%UIMA_HOME%/lib/uimaj-as-core.jar</p></li><li class="listitem"><p>%UIMA_HOME%/lib/uima-core.jar</p></li><li class="listitem"><p>%UIMA_HOME%/apache-activemq-5.4.1/activemq-all-5.4.1.jar</p></li></ul></div>
            </li><li class="listitem">
              <p>Parameters:</p>
              <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="code">-Djava.util.logging.config.file=%UIMA_HOME%/config/MonitorLogger.properties</code>
                  - specifies the logging file where the information is written to</p></li><li class="listitem"><p><code class="code">org.apache.uima.aae.jmx.monitor.JmxMonitor</code> -
                  the class whose main method is invoked</p></li><li class="listitem"><p><code class="code">uri</code> - the URI of the jmx instance to monitor.</p></li><li class="listitem"><p><code class="code">interval</code> - the (optional) 
                  sampling interval, in milliseconds (default = 1000)</p></li></ul></div>                 
            </li></ul></div><p>
        </p>
        
        <p>When run in this manner, it is not (currently) possible to specify the
          log message formatting class; the multi-line output format is always used.</p>
      </div>     
      
      <div class="section" title="5.2.3.&nbsp;Monitoring output"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.jmx_sampling.output">5.2.3.&nbsp;Monitoring output</h3></div></div></div>
        
        <p>The monitoring program combines information from the JMX measures, including the associated
          Queue Broker, sampling accumulating measurements at the specified sampling interval, and produces
          the following outputs:
          
          </p><div class="informaltable">
            <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-bottom: 0.5pt solid black; " align="center">Units</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Input queue depth</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of CASes waiting to be processed by a service</td><td style="border-bottom: 0.5pt solid black; ">count</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Reply queue depth</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of CASes returned to the client but not yet picked up by the client</td><td style="border-bottom: 0.5pt solid black; ">count</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">CASes processed in interval</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Number of CASes processed in this sampling interval</td><td style="border-bottom: 0.5pt solid black; ">count</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Idle time in interval</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The total time this service has been idle during this interval</td><td style="border-bottom: 0.5pt solid black; ">milli seconds</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Analysis time in interval</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">The sum of the times spent in analysis by the service during this interval, 
                    including analysis time spent in delegates, recursively</td><td style="border-bottom: 0.5pt solid black; ">milli seconds</td></tr><tr><td style="border-right: 0.5pt solid black; ">Cas Pool free Cas Count</td><td style="border-right: 0.5pt solid black; ">Number of available CASes in the Cas Pool at the end of the interval</td><td style="">count</td></tr></tbody></table>
          </div><p>
        </p>
        
        <p>In addition to the performance metrics the monitor also provides basic service information:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <p>Service name</p>
            </li><li class="listitem">
              <p>Is service top level</p>
            </li><li class="listitem">
              <p>Is service remote</p>
            </li><li class="listitem">
              <p>Is service a cas multiplier</p>
            </li><li class="listitem">
              <p>Number of processing threads</p>
            </li><li class="listitem">
              <p>Service uptime (milliseconds)</p>
            </li></ul></div><p> 
        </p>
      </div>
    </div>
  
  <div class="section" title="5.3.&nbsp;Tuning"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.mt.tuning">5.3.&nbsp;Tuning</h2></div></div></div>
    
        
    <div class="section" title="5.3.1.&nbsp;Tuning procedure"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.tuning.approach">5.3.1.&nbsp;Tuning procedure</h3></div></div></div>
      
      <p>This section is a cookbook of best practices for tuning a UIMA AS deployment.  The summary information
        provided by the Monitor program is used to guide the tuning.</p>

    <p>The main metric for detecting an overloaded service is the input queue depth. If it is growing or high, the service 
           is not able to keep up with the load. There are more CASes arriving at the queue than the service can process. 
           Consider increasing number of instances of the services within the JVM (if on a multi-core machine having 
           additional capacity), or deploy additional instances of the service.</p>

    <p>The main metric for detecting idle service is the idle time. If it is high, it can indicate that the service is not 
          receiving enough CASes. This can be caused by a bottleneck in the service's client; supporting evidence for this
          can be a high reply queue depth for the client - indicating the client is overloaded. 
          If the idle time is zero, the service may be saturated; adding more instances could
          relieve a bottleneck.</p>

    <p>A CasPool free Cas Count of 0 can point to a bottleneck in a service's client; supporting
      evidence for this can be a high idle time. In this case, the service does not have enough CASes in its pool and is 
          forced to wait. Remember that a CAS is not returned to the Service's CAS pool until the client 
          (which can be a parent asynchronous aggregate) signals it can be.
          A typical reason is a slow client (look for evidence such as a high reply queue depth). Consider 
          incrementing service's Cas pool and check the client's metrics to determine a reason why it is slow.</p>
     
    <p>An asynchronous system must have something that limits the generation of
       new work to do. CasPools are the mechanism used by UIMA AS to do this.
       Also, because CASes can have large memory requirements, it is
       important to limit the number and sizes of CASes in a process.</p>     
      
    </div>

    <div class="section" title="5.3.2.&nbsp;Tuning Settings"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.tuning.settings">5.3.2.&nbsp;Tuning Settings</h3></div></div></div>
      
      <p>This section has a list of the tuning parameters and a description of what they do and how they interact.</p>
      <div class="informaltable">
        <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-bottom: 0.5pt solid black; " align="center">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of services on different machines started</td><td style="border-bottom: 0.5pt solid black; ">You can adjust the number of machines assigned to a particular service,
                even dynamically, by just starting / stopping additional servers that specify
                the same input queue.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">number of instances of a service</td><td style="border-bottom: 0.5pt solid black; ">This is similar to the number of services on different machines started, above, 
                but specifies replication of an AS Primitive within one JVM.  This is useful for making
                use of multi-core machines sharing a common memory - large tables that might be 
                part of the analysis algorithm can be shared by all instances.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">CAS pool size</td><td style="border-bottom: 0.5pt solid black; ">This size limits the number of CASes being processed asynchronously.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">casMultiplier poolSize</td><td style="border-bottom: 0.5pt solid black; ">This size limits the number of CASes generated by a CAS Multiplier that are being processed asynchronously.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Service input queue prefetch</td><td style="border-bottom: 0.5pt solid black; ">If set greater than 0, allows up to "n" CASes to be pulled into one service provider, at a time.
                This can increase throughput, but can hurt latency, since one service may have several CASes pulled into it,
                queued up, while another instance of the service could be "starved" and be sitting there idle. </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Specifying async="true"/"false" on an aggregate</td><td style="border-bottom: 0.5pt solid black; ">The default is false, because there is less overhead (no queues are set up, etc.).  Setting this to 
                "true" allows multiple CASes to flow simultaneously in the aggregate.</td></tr><tr><td style="border-right: 0.5pt solid black; ">remoteReplyQueueScaleout</td><td style="">This parameter indicates the number of threads that will be deployed to read from the remote reply queue.
                Set to &gt; 1 if deserialization time of replies is a bottleneck.</td></tr></tbody></table>
      </div>     
      
    </div>
    
    </div>


    <div class="section" title="5.4.&nbsp;Debugging"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.mt.debugging">5.4.&nbsp;Debugging</h2></div></div></div>
	    

		<p>One of the strongest UIMA features is the ability to develop and
			debug components in isolation from each other, and then to incrementally
			combine components and scaleout complexity. All that is needed to exercise
			each configuration are one or more appropriate input CASes.
		</p>
	
		<p>It is strongly advised to first test UIMA components in the core UIMA 
			environment with a variety of input CASes. If the entire 
			application will not fit in a single process, deploy remote delegates as
			UIMA AS primitives with only a single instance
			(see <a class="xref" href="#ugr.async.ov.concepts.deploying.multiples" title="1.4.4.1.&nbsp;Configuring multiple instances of components">Section&nbsp;1.4.4.1, &#8220;Multiple Instances&#8221;</a>),
			and access them via JMS service descriptors 
			(see <a class="xref" href="#ugr.async.ov.concepts.jms_descriptor" title="1.7.&nbsp;JMS Service Descriptor">Section&nbsp;1.7, &#8220;JMS Service Descriptor&#8221;</a>). 
			Run as much input data thru this "single-threaded" configuration as needed 
			to eliminate most "algorithmic" errors and to measure performance against 
			analysis time objectives. Thread safety and analysis
			ordering issues can then be addressed separately.</p> 
	
		<p><span class="bold"><strong>Thread safety bugs.</strong></span> Components intended to be run 
			multi-threaded should first be deployed as a multiple instance UIMA AS service 
			(again see <a class="xref" href="#ugr.async.ov.concepts.deploying.multiples" title="1.4.4.1.&nbsp;Configuring multiple instances of components">Section&nbsp;1.4.4.1, &#8220;Multiple Instances&#8221;</a>),
			and fed their input CASes with a driver
			capable of keeping all instances busy at the same time. A good application
			is the sample driver $UIMA_HOME/bin/runRemoteAsyncAE; use the -p argument 
			to increase the number of outstanding CAS requests sent to the target service.
			When looking for threading problems try using http://findbugs.sourceforge.net/. 
			In addition to looking for exceptions caused by thread unsafe code, check that
			the single and multi-threaded analysis results are the same.
		</p>

		<p><span class="bold"><strong>Analysis ordering bugs.</strong></span>
			In a core UIMA aggregate CASes are processed by each delegate in input order.
			This relationship changes for the same aggregate deployed asynchronously if one of the delegates
			is replicated, as CASes are progressed in parallel and then progress thru the subsequent aggregate
			flow in a different order then they are received.
			Similarly with a delegate CasMultiplier in a core UIMA aggregate each child CAS is processed 
			to completion before the next child CAS is started and the parent CAS is processed last.
			When running asynchronously the parent CAS 
			can arrive at downstream components ahead of its children because the parent
			is released from a CasMultiplier immediately after the last child is created.
			For applications which require all children to be processed before their parent,
			use	the processParentLast flag (see	<a class="xref" href="#ugr.ref.async.deploy.descriptor.ae" title="3.9.&nbsp;Analysis Engine">Section&nbsp;3.9, &#8220;Analysis Engine&#8221;</a>).
		</p>

		<p><span class="bold"><strong>Timing issues.</strong></span>
			Invariably with complex analytics, some components will be slower and some artifacts 
			will take longer to process than desired. Making performance improvements relies on
			identifying components running slower than expected and capturing the slow-running artifacts  
			to study in detail. 
		</p>

	    <div class="section" title="5.4.1.&nbsp;Error Reporting and Tracing"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.debugging.tracing">5.4.1.&nbsp;Error Reporting and Tracing</h3></div></div></div>
	      
	      <p>After the system is scaled out and substantially more data is being processed
	      	it is likely that additional errors will occur.
	      </p>

	      <p>Java errors at any component level
			are propagated back to the component originating the request
		    (unless suppressed by UIMA AS error handling options, 
		    see <a class="xref" href="#ugr.async.eh.error_handling_overview" title="2.3.&nbsp;Error handling overview">Section&nbsp;2.3, &#8220;Error handling overview&#8221;</a>).
		    The error stack traces the call chain of UIMA AS components, within
		    colocated aggregate components and across remote services which are 
		    shared by multiple clients. Some errors can be resolved with this
		    information alone.
			</p>

	      <p>If process timeouts are not used 
		    (see <a class="xref" href="#ugr.ref.async.deploy.descriptor.errorconfig" title="3.10.&nbsp;Error Configuration descriptors">Section&nbsp;3.10, &#8220;Error Configuration descriptors&#8221;</a>)
		    an asynchronous system can hang if one analysis step somewhere in
		    the system has hung. Given many CASes in process at the same time it can
		    be useful to create a custom trace of CAS activity by appropriate logging
		    in <span class="bold"><strong>a custom flow controller</strong></span>. 
		    Such logging would have a unique identifier in every CAS,
			usually a singleton FeatureStructure with a unique String feature. Identifiers
			for child CASes should include some reference to the CasMultiplier they were
			created from as well as their parent CAS.
		  </p>

		  <p>The flow controller is also the ideal place to measure timing statistics
		  	for components of interest. Global stats can easily be measured using the 
		  	time between flow steps, and time
		  	thresholds used to flag specific CASes causing problems. Again the unique
		  	CAS identifier can be quite useful here.
		  </p>

	    </div>
	
	    <div class="section" title="5.4.2.&nbsp;CAS Logging"><div class="titlepage"><div><div><h3 class="title" id="ugr.async.mt.debugging.caslogging">5.4.2.&nbsp;CAS Logging</h3></div></div></div>
	      
	      <p>Within a UIMA AS asynchronous aggregate, CASes can be saved before sending to any local or remote 
	        	delegate and later used to reproduce a problem in a simple unit testing environment.
	        	Control of CAS logging is done via Java properties:
	      </p>
	        <div class="informaltable">
	          <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Property</th><th style="border-bottom: 0.5pt solid black; " align="center">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_CASLOG_BASE_DIRECTORY</td><td style="border-bottom: 0.5pt solid black; ">optional; this is the directory under which sub-directories with
	                	XmiCas files will be created. If not specified, the process's current directory 
	                	will be the base.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_CASLOG_COMPONENT_ARRAY</td><td style="border-bottom: 0.5pt solid black; ">This is a space separated list of delegates keys. If a
						delegate is nested inside a co-located async aggregate, the name would include the key
						name of the aggregate, e.g. "someAggName/someDelName". The XmiCas files will then be
						written into $UIMA_CASLOG_BASE_DIRECTORY/someAggName-someDelName/</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_CASLOG_TYPE_NAME</td><td style="border-bottom: 0.5pt solid black; ">optional; this is the name of a FeatureStructure in the CAS
	                	containing a unique string to use to name each XmiCas file. If not specified, XmiCas
	                	file name will be N.xmi, where N is the time in microseconds since the component was
	                	initialized.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_CASLOG_FEATURE_NAME</td><td style="border-bottom: 0.5pt solid black; ">optional unless the TYPE_NAME is specified; this parameter
	                	gives the string feature to use. If the string value contains one or more
	                	"/" characters only the text after the last "/" will be used.</td></tr><tr><td style="border-right: 0.5pt solid black; ">UIMA_CASLOG_VIEW_NAME</td><td style="">optional; if the TYPE_NAME and FEATURE_NAME parameters are specified 
	                    this string selects the CAS view used to access the FeatureStructure with 
	                    unique string feature.</td></tr></tbody></table>
	        </div>
	    </div>

  </div>
  
  

</div> 
  <div class="chapter" title="Chapter&nbsp;6.&nbsp;Asynchronous Scaleout Camel Driver" id="ugr.async.camel.driver"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;6.&nbsp;Asynchronous Scaleout Camel Driver</h2></div></div></div>
  
  <div class="section" title="6.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.camel.driver.component.overview">6.1.&nbsp;Overview</h2></div></div></div>
    
    <p>
    <a class="ulink" href="http://camel.apache.org" target="_top">Apache Camel</a> is an integration framework based on 
    <a class="ulink" href="http://camel.apache.org/enterprise-integration-patterns.html" target="_top">Enterprise Integration Patterns</a>
    which uses routes for rule-based message routing and mediation. The camel project
    has a large number of components which provide access to a wide variety of
    technologies and are the building blocks of the routes. The Asynchronous Scaleout Camel Driver
    is a component to integrate UIMA AS into Camel.
    </p>
    </div> 
    <div class="section" title="6.2.&nbsp;How does it work?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.camel.driver.component">6.2.&nbsp;How does it work?</h2></div></div></div>
    
    <p>
    The Asynchronous Scaleout Camel Driver sends the camel message body (without headers) to
    a specified UIMA AS processing pipeline. Accessing the analysis results which
    are written into the CAS is not possible from a camel route.
    There are basically two usage scenarios. The Camel Driver can be used to drive the processing
    of a UIMA AS cluster in which each server instance runs a cas multiplier to fetch the actual
    document from a database. In this scenario the camel route only sends an ID of the document to
    the cas multiplier which does the actual fetching of the document. In the second usage scenario
    the Camel Driver is used to send a document in a one way fashion to a UIMA AS processing
    pipeline which then takes care of processing it. In case an error occurs inside the processing
    pipeline the exception is forwarded to camel and set on the message as response. Error handling
    is described in the
    <a class="ulink" href="http://camel.apache.org/error-handling-in-camel.html" target="_top">Error handling in Camel</a>
    documentation.
    </p>
    <p>
    The camel driver expects a string message body; if it is not of the type string
    it might be automatically converted by camel type converters. The string message
    body is set as the CAS's document text. An Analysis Engine calls
    CAS CAS.getDocumentText() to retrieve the string.
    </p>
  </div>
  <div class="section" title="6.3.&nbsp;URI Format"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.camel.driver.uri.format">6.3.&nbsp;URI Format</h2></div></div></div>
    
    <p>The Asynchronous Scaleout Camel Driver is configured with a configuration string. The 
    configuration string must contain the broker location and name of the JMS queue used to
    communicate with UIMA AS. It has the following format
    </p><pre class="programlisting">uimadriver:brokerURL?queue=nameofqueue&amp;CasPoolSize=n&amp;Timeout=t</pre><p>
    which could for example be specified as
    </p><pre class="programlisting">uimadriver:tcp://localhost:61616?queue=TextAnalysisQueue</pre><p>.
    The CasPoolSize parameter is optional but if it is present n must be an integer
    which is larger than zero, otherwise the UIMA AS default will be used.
    The Timeout parameter is optional but if present t in milliseconds must zero or 
    larger.
    </p>
  </div>
  <div class="section" title="6.4.&nbsp;Sample"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.camel.driver.sample">6.4.&nbsp;Sample</h2></div></div></div>
    
    <p>Camel enables a developer to create quickly all kinds of applications out of
    existing and custom components. The sample demonstrates how UIMA AS is integrated
    with other technologies. Readers who are new to camel should read
    the <a class="ulink" href="http://camel.apache.org/book-getting-started.html" target="_top">Getting Started</a>
    chapter in the camel documentation.</p>
    <p> 
    First a simple sample: A user wants to test a UIMA AS processing pipeline, sending it
    a set of test documents to process. The plain text test documents
    are located in a folder "/test-data". A camel route for this defined with
    <a class="ulink" href="http://camel.apache.org/dsl.html" target="_top">Java DSL</a> could look like this:
    </p><pre class="programlisting">
     from("file://test-data?noop=true").
     to("uimadriver:tcp://localhost:61616?queue=TextAnalysisQueue");
    </pre><p>
    In the route above the file component sends a message for every file to the
    uimadriver component. The message contains a reference to the file but not the
    content of the file itself. The uimadriver component expects a message with string body as input.
    An internal camel type converter will read in the bytes of the file, decode them
    into characters with the default platform encoding and then create a string object
    which is passed to the uimadriver component. The uimadriver then puts the 
    string into a CAS and sends it via the UIMA AS Client API to a processing pipeline.
    Note that results from the returned CAS cannot be retrieved in a camel route.
    </p>
    <p>
    A more complex sample. A web site has an area where people can upload pictures. 
    The pictures must be checked for appropriate content. The pictures are pushed to
    the site via http, stored in a database and assigned to the human controllers to
    classify them either as appropriate or non-appropriate. That is achieved with an
    existing camel route and a servlet which receives the images and sends them to the camel route.
    </p><pre class="programlisting">
    from("direct:start").
    to("imagewriter").
    to("jms:queue:HumanPictureAnalysisQueue");
    </pre><p>
    The message containing the image is received by the direct:start endpoint, 
    the image is written to a database and replaced with a string identifier
    by the "imagewriter" component, in the last step the camel jms component posts
    the identifier on a JMS queue to notify the reception of a new image. The notification
    is received by a client tool which the human controllers use to classify 
    an image.
    </p>
    <p>
    To lessen the workload on the human reviewers, a system should automatically classify the pictures and
    only assign questionable cases to human reviewers. The automatic classification is
    done by an UIMA Analysis Engine. The AE can mark an image with one of three classes
    appropriate, non-appropriate and unknown. In the case of unknown the AE is not confident
    enough which of the first two classes is correct. To be scalable, the processing pipeline is hosted
    by UIMA AS and contains three AEs, one to fetch the image from
    the database, a classification AE and an AE to write the class of the image back to the database.
    The first AE is typical a cas multiplier and receives a CAS which only contains the string identifier
    but not the actual image. The cas muliplier uses the identifer to fetch the image from
    the database and outputs a new CAS with the actual image. The Camel route blocks until the CAS is processed
    by the following two AEs and depending on the class in the database the picture is assigned to a human
    controller or not.
    </p><pre class="programlisting">
    from("direct:start").
    to("imagewriter").
    to("uimadriver:tcp://localhost:61616?queue=UimaPictureAnalysisQueue").
    to("class-retriever").
    // filters messages with class appropriate and non-appropriate
    filter(header("picture-class").isEqualTo("unkown")).
    to("jms:queue:HumanPictureAnalysisQueue");
    </pre><p>
    The first part is identical, after the imagewriter the string identifier is
    send to the UIMA AS processing pipeline which writes the image class back to the database.
    The class is retrieved with the custom class-retriever component and written to a message header
    field, only if the class is unknown the image is assigned for human classification.
    </p>
    
    <p>Note: instead of using a CAS multiplier, a more straight-forward approach would use just one CAS, 
      having 2 views: one view would contain the string identifier of the image, and the other view would 
      have the image to be analyzed (or a reference to it in the DB).</p>
  </div>
  <div class="section" title="6.5.&nbsp;Implementation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.camel.driver.implementation">6.5.&nbsp;Implementation</h2></div></div></div>
  
  <p>The Asynchronous Scaleout Camel Driver is a typical camel component. The camel
  documentation <a class="ulink" href="http://camel.apache.org/writing-components.html" target="_top">
  Writing Components</a> describes how camel components are
  written. The source code can be found in the uimaj-as-camel project. The implementation
  defines an asynchronous producer endpoint, which is implemented in the
  <code class="code">org.apache.uima.camel.UimaAsProducer</code> class. The <code class="code">UimaAsProducer.process</code> method gets
  the string body of the message, wraps it in a CAS object and sends it to UIMA AS.
  Since the producer is asynchronous the camel message is registered with the reference id of
  the sent CAS in an intermediate map, when the CAS comes back from UIMA AS, the camel message is looked up
  with the reference id of the CAS and the processing of the camel message is completed. 
  For further details please read the <code class="code">UimaAsProducer</code> implementation code.
  </p>
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;7.&nbsp;Asynchronous Scaleout Tools" id="ugr.async.tools"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;7.&nbsp;Asynchronous Scaleout Tools</h2></div></div></div>
  
  <div class="section" title="7.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.tools.overview">7.1.&nbsp;Overview</h2></div></div></div>
    
    <p>
    Several tools are available to use with UIMA-AS, including tools to start a JMS Broker,
    deploy a UIMA-AS service, start up a trivial client that reads documents from a directory 
    and sends them to a remote service, and query a named service for its meta data.
    </p>
    <p>Additionally, there is an extension to the Component Descriptor Editor that
    gives a form-based editor capability to edit deployment descriptors, along with wizards to 
    enable creating these kinds of descriptors.</p>
  </div> 
  <div class="section" title="7.2.&nbsp;Starting a broker"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.tools.startBroker">7.2.&nbsp;Starting a broker</h2></div></div></div>
    
    <p>
    The <code class="code">startBroker</code> script starts an ActiveMQ broker that can then be used to connect UIMA-AS
    clients to UIMA-AS Services.
    </p>
    <p>All arguments are optional; if none are given, the broker is started on the same
    machine using defaults.  See the script for details on how this can be configured.</p>
  </div>
  <div class="section" title="7.3.&nbsp;Deploying a UIMA-AS Service"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.tools.deploying">7.3.&nbsp;Deploying a UIMA-AS Service</h2></div></div></div>
    
    <p>
    The <code class="code">deployAsyncService</code> script deploys one or more UIMA-AS services.  
    Its arguments are one or more paths to deployment descriptors.
    </p>
    <p>
    The Java source code that does the deploying is in the class 
    <code class="code">org.apache.uima.adapter.jms.service.UIMA_Service</code>, in the 
    uimaj-as-activemq project. 
    </p>
  </div>
  <div class="section" title="7.4.&nbsp;Running a UIMA-AS Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.tools.client">7.4.&nbsp;Running a UIMA-AS Client</h2></div></div></div>
    
    <p>The runRemoteAsyncAE script is a sample application  
    that calls a Remote Asynchronous Analysis Engine on a collection of artifacts, represented by
    files in a directory.
    </p>
    <p>
      The command takes several arguments:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>brokerUrl - the url of the broker to use to connect to the service</p>
        </li><li class="listitem"><p>service name - this is the endpoint name of the service, 
        and must match what is in the service's deployment descriptor. </p>
        </li></ul></div><p>
      </p><p>The rest of the arguments are optional:</p><p>
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>-d Specifies a deployment descriptor. 
        The specified service will be deployed before processing begin, 
        and the service will be undeployed after processing completes. 
        Multiple -d entries can be given.</p>
        </li><li class="listitem"><p>-c Specifies a CollectionReader descriptor. 
        The client will read CASes from the CollectionReader and 
        send them to the service for processing. If this option is omitted, 
        one empty CAS will be sent to the service 
        (useful for services containing a CAS Multiplier acting as a collection reader).</p></li><li class="listitem"><p>-p Specifies CAS pool size, which determines the maximum number 
        of requests that can be outstanding.</p></li><li class="listitem"><p>-f Specifies the initial FS heap size in bytes of each CAS in the pool.</p></li><li class="listitem"><p>-o Specifies an Output Directory. 
        All CASes received by the client's CallbackListener will be serialized to XMI 
        in the specified OutputDir. If omitted, no XMI files will be output.</p></li><li class="listitem"><p>-t Specifies a timeout period in seconds. 
        If a CAS does not return within this time period it is considered an error. 
        By default there is no timeout, so the client will wait forever.</p></li><li class="listitem"><p>-i Causes the client to ignore errors returned from the service. 
        If not specified, the client terminates on the first error.</p></li><li class="listitem"><p>-log Output details on each process request.</p></li><li class="listitem"><p>-uimaEeDebug true causes various debugging things to happen, including 
        <span class="emphasis"><em>not</em></span> deleting the generated spring file generated by running dd2spring. 
        This parameter only affects deployments specified using the -d parameter that follow it in the command line sequence.</p></li></ul></div><p>
    </p>
    <p>The source code for this is in the class 
    <code class="code">org.apache.uima.examples.as.RunRemoteAsyncAE.java</code>
    in the project <code class="code">uimaj-as-activemq</code>.</p>
  </div>
    <div class="section" title="7.5.&nbsp;Querying for a service's metadata"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.async.tools.getMeta">7.5.&nbsp;Querying for a service's metadata</h2></div></div></div>
    
    <p>
    The <code class="code">getMetaRequest</code> script connects to an Active MQ broker and attempts to 
    query a particular named service's metadata.  This can be useful to confirm that 
    a service actually exists and is started, on a particular broker.
    </p>
    <p>This takes several arguments:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>broker Uri - the Uri of the JMS broker used by the UIMA-AS Service</p></li><li class="listitem"><p>service name - the name of the UIMA-AS service, same as the "endpoint" name.</p></li><li class="listitem"><p>[optional] -verbose  - to output more information</p></li></ul></div><p>
      There are other arguments which are normally not given; if needed, they are specified as
      Java -D (defined properties) arguments:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>-Dactivemq.broker.jmx.port=xxx - override the port
        being used for JMX (defaults to 1099)</p></li><li class="listitem"><p>-Dactivemq.broker.jmx.domain=xxx - use <code class="code">xxx</code>
        as the JMX domain.  This normally never needs to be done unless multiple brokers are run on the same node 
        as is sometimes done for unit tests.</p></li></ul></div><p>
    </p>
    <p>This command will connect to the specified broker at its JMX port and query
    to verify that this broker has the named service registered.  It then will 
    send a <code class="code">getMeta</code> request to the named service and retrieve its metadata.</p>
    <p>The source code for this is in the class
    <code class="code">org.apache.uima.examples.as.GetMetaRequest</code> in the project
    <code class="code">uimaj-as-activemq</code>.</p>
  </div>
  
  
</div>

  
</div></body></html>